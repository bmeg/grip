// Code generated by protoc-gen-go.
// source: aql.proto
// DO NOT EDIT!

/*
Package aql is a generated protocol buffer package.

It is generated from these files:
	aql.proto

It has these top-level messages:
	GraphQuery
	GraphQuerySet
	GraphStatement
	HasStatement
	HasValueStatement
	SelectStatement
	FoldStatement
	Vertex
	Edge
	QueryResult
	ResultRow
	EditResult
	GraphElement
	Graph
	GraphID
	ElementID
	IndexID
	IndexQuery
	IndexTermCount
	Timestamp
	Empty
*/
package aql

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/struct"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Condition int32

const (
	Condition_UNKNOWN_CONDITION Condition = 0
	Condition_EQ                Condition = 1
	Condition_NEQ               Condition = 2
	Condition_GT                Condition = 3
	Condition_GTE               Condition = 4
	Condition_LT                Condition = 5
	Condition_LTE               Condition = 6
	Condition_BETWEEN           Condition = 7
	Condition_INSIDE            Condition = 8
	Condition_OUTSIDE           Condition = 9
	Condition_WITHIN            Condition = 10
	Condition_WITHOUT           Condition = 11
)

var Condition_name = map[int32]string{
	0:  "UNKNOWN_CONDITION",
	1:  "EQ",
	2:  "NEQ",
	3:  "GT",
	4:  "GTE",
	5:  "LT",
	6:  "LTE",
	7:  "BETWEEN",
	8:  "INSIDE",
	9:  "OUTSIDE",
	10: "WITHIN",
	11: "WITHOUT",
}
var Condition_value = map[string]int32{
	"UNKNOWN_CONDITION": 0,
	"EQ":                1,
	"NEQ":               2,
	"GT":                3,
	"GTE":               4,
	"LT":                5,
	"LTE":               6,
	"BETWEEN":           7,
	"INSIDE":            8,
	"OUTSIDE":           9,
	"WITHIN":            10,
	"WITHOUT":           11,
}

func (x Condition) String() string {
	return proto.EnumName(Condition_name, int32(x))
}
func (Condition) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ElementType int32

const (
	ElementType_UNKNOWN_TYPE ElementType = 0
	ElementType_VERTEX       ElementType = 1
	ElementType_EDGE         ElementType = 2
)

var ElementType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "VERTEX",
	2: "EDGE",
}
var ElementType_value = map[string]int32{
	"UNKNOWN_TYPE": 0,
	"VERTEX":       1,
	"EDGE":         2,
}

func (x ElementType) String() string {
	return proto.EnumName(ElementType_name, int32(x))
}
func (ElementType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type GraphQuery struct {
	Graph string            `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Query []*GraphStatement `protobuf:"bytes,2,rep,name=query" json:"query,omitempty"`
}

func (m *GraphQuery) Reset()                    { *m = GraphQuery{} }
func (m *GraphQuery) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery) ProtoMessage()               {}
func (*GraphQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GraphQuery) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *GraphQuery) GetQuery() []*GraphStatement {
	if m != nil {
		return m.Query
	}
	return nil
}

type GraphQuerySet struct {
	Queries []*GraphQuery `protobuf:"bytes,1,rep,name=queries" json:"queries,omitempty"`
}

func (m *GraphQuerySet) Reset()                    { *m = GraphQuerySet{} }
func (m *GraphQuerySet) String() string            { return proto.CompactTextString(m) }
func (*GraphQuerySet) ProtoMessage()               {}
func (*GraphQuerySet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GraphQuerySet) GetQueries() []*GraphQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

type GraphStatement struct {
	// Types that are valid to be assigned to Statement:
	//	*GraphStatement_V
	//	*GraphStatement_E
	//	*GraphStatement_Has
	//	*GraphStatement_HasLabel
	//	*GraphStatement_HasId
	//	*GraphStatement_HasValue
	//	*GraphStatement_In
	//	*GraphStatement_Out
	//	*GraphStatement_InEdge
	//	*GraphStatement_OutEdge
	//	*GraphStatement_Both
	//	*GraphStatement_BothEdge
	//	*GraphStatement_As
	//	*GraphStatement_Select
	//	*GraphStatement_Values
	//	*GraphStatement_Render
	//	*GraphStatement_Limit
	//	*GraphStatement_Count
	//	*GraphStatement_GroupCount
	//	*GraphStatement_Distinct
	//	*GraphStatement_Match
	//	*GraphStatement_Import
	//	*GraphStatement_Map
	//	*GraphStatement_Fold
	//	*GraphStatement_VertexFold
	//	*GraphStatement_Filter
	//	*GraphStatement_FilterValues
	//	*GraphStatement_VertexFromValues
	Statement isGraphStatement_Statement `protobuf_oneof:"statement"`
}

func (m *GraphStatement) Reset()                    { *m = GraphStatement{} }
func (m *GraphStatement) String() string            { return proto.CompactTextString(m) }
func (*GraphStatement) ProtoMessage()               {}
func (*GraphStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isGraphStatement_Statement interface {
	isGraphStatement_Statement()
}

type GraphStatement_V struct {
	V *google_protobuf1.ListValue `protobuf:"bytes,1,opt,name=v,oneof"`
}
type GraphStatement_E struct {
	E *google_protobuf1.ListValue `protobuf:"bytes,2,opt,name=e,oneof"`
}
type GraphStatement_Has struct {
	Has *HasStatement `protobuf:"bytes,5,opt,name=has,oneof"`
}
type GraphStatement_HasLabel struct {
	HasLabel *google_protobuf1.ListValue `protobuf:"bytes,6,opt,name=has_label,json=hasLabel,oneof"`
}
type GraphStatement_HasId struct {
	HasId *google_protobuf1.ListValue `protobuf:"bytes,7,opt,name=has_id,json=hasId,oneof"`
}
type GraphStatement_HasValue struct {
	HasValue *HasValueStatement `protobuf:"bytes,8,opt,name=has_value,json=hasValue,oneof"`
}
type GraphStatement_In struct {
	In *google_protobuf1.ListValue `protobuf:"bytes,10,opt,name=in,oneof"`
}
type GraphStatement_Out struct {
	Out *google_protobuf1.ListValue `protobuf:"bytes,11,opt,name=out,oneof"`
}
type GraphStatement_InEdge struct {
	InEdge *google_protobuf1.ListValue `protobuf:"bytes,12,opt,name=in_edge,json=inEdge,oneof"`
}
type GraphStatement_OutEdge struct {
	OutEdge *google_protobuf1.ListValue `protobuf:"bytes,13,opt,name=out_edge,json=outEdge,oneof"`
}
type GraphStatement_Both struct {
	Both *google_protobuf1.ListValue `protobuf:"bytes,14,opt,name=both,oneof"`
}
type GraphStatement_BothEdge struct {
	BothEdge *google_protobuf1.ListValue `protobuf:"bytes,15,opt,name=both_edge,json=bothEdge,oneof"`
}
type GraphStatement_As struct {
	As string `protobuf:"bytes,20,opt,name=as,oneof"`
}
type GraphStatement_Select struct {
	Select *SelectStatement `protobuf:"bytes,21,opt,name=select,oneof"`
}
type GraphStatement_Values struct {
	Values *SelectStatement `protobuf:"bytes,22,opt,name=values,oneof"`
}
type GraphStatement_Render struct {
	Render *google_protobuf1.Value `protobuf:"bytes,23,opt,name=render,oneof"`
}
type GraphStatement_Limit struct {
	Limit int64 `protobuf:"varint,25,opt,name=limit,oneof"`
}
type GraphStatement_Count struct {
	Count string `protobuf:"bytes,26,opt,name=count,oneof"`
}
type GraphStatement_GroupCount struct {
	GroupCount string `protobuf:"bytes,30,opt,name=group_count,json=groupCount,oneof"`
}
type GraphStatement_Distinct struct {
	Distinct *google_protobuf1.ListValue `protobuf:"bytes,31,opt,name=distinct,oneof"`
}
type GraphStatement_Match struct {
	Match *GraphQuerySet `protobuf:"bytes,40,opt,name=match,oneof"`
}
type GraphStatement_Import struct {
	Import string `protobuf:"bytes,50,opt,name=import,oneof"`
}
type GraphStatement_Map struct {
	Map string `protobuf:"bytes,51,opt,name=map,oneof"`
}
type GraphStatement_Fold struct {
	Fold *FoldStatement `protobuf:"bytes,52,opt,name=fold,oneof"`
}
type GraphStatement_VertexFold struct {
	VertexFold *FoldStatement `protobuf:"bytes,53,opt,name=vertex_fold,json=vertexFold,oneof"`
}
type GraphStatement_Filter struct {
	Filter string `protobuf:"bytes,54,opt,name=filter,oneof"`
}
type GraphStatement_FilterValues struct {
	FilterValues string `protobuf:"bytes,55,opt,name=filter_values,json=filterValues,oneof"`
}
type GraphStatement_VertexFromValues struct {
	VertexFromValues string `protobuf:"bytes,56,opt,name=vertex_from_values,json=vertexFromValues,oneof"`
}

func (*GraphStatement_V) isGraphStatement_Statement()                {}
func (*GraphStatement_E) isGraphStatement_Statement()                {}
func (*GraphStatement_Has) isGraphStatement_Statement()              {}
func (*GraphStatement_HasLabel) isGraphStatement_Statement()         {}
func (*GraphStatement_HasId) isGraphStatement_Statement()            {}
func (*GraphStatement_HasValue) isGraphStatement_Statement()         {}
func (*GraphStatement_In) isGraphStatement_Statement()               {}
func (*GraphStatement_Out) isGraphStatement_Statement()              {}
func (*GraphStatement_InEdge) isGraphStatement_Statement()           {}
func (*GraphStatement_OutEdge) isGraphStatement_Statement()          {}
func (*GraphStatement_Both) isGraphStatement_Statement()             {}
func (*GraphStatement_BothEdge) isGraphStatement_Statement()         {}
func (*GraphStatement_As) isGraphStatement_Statement()               {}
func (*GraphStatement_Select) isGraphStatement_Statement()           {}
func (*GraphStatement_Values) isGraphStatement_Statement()           {}
func (*GraphStatement_Render) isGraphStatement_Statement()           {}
func (*GraphStatement_Limit) isGraphStatement_Statement()            {}
func (*GraphStatement_Count) isGraphStatement_Statement()            {}
func (*GraphStatement_GroupCount) isGraphStatement_Statement()       {}
func (*GraphStatement_Distinct) isGraphStatement_Statement()         {}
func (*GraphStatement_Match) isGraphStatement_Statement()            {}
func (*GraphStatement_Import) isGraphStatement_Statement()           {}
func (*GraphStatement_Map) isGraphStatement_Statement()              {}
func (*GraphStatement_Fold) isGraphStatement_Statement()             {}
func (*GraphStatement_VertexFold) isGraphStatement_Statement()       {}
func (*GraphStatement_Filter) isGraphStatement_Statement()           {}
func (*GraphStatement_FilterValues) isGraphStatement_Statement()     {}
func (*GraphStatement_VertexFromValues) isGraphStatement_Statement() {}

func (m *GraphStatement) GetStatement() isGraphStatement_Statement {
	if m != nil {
		return m.Statement
	}
	return nil
}

func (m *GraphStatement) GetV() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_V); ok {
		return x.V
	}
	return nil
}

func (m *GraphStatement) GetE() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_E); ok {
		return x.E
	}
	return nil
}

func (m *GraphStatement) GetHas() *HasStatement {
	if x, ok := m.GetStatement().(*GraphStatement_Has); ok {
		return x.Has
	}
	return nil
}

func (m *GraphStatement) GetHasLabel() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_HasLabel); ok {
		return x.HasLabel
	}
	return nil
}

func (m *GraphStatement) GetHasId() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_HasId); ok {
		return x.HasId
	}
	return nil
}

func (m *GraphStatement) GetHasValue() *HasValueStatement {
	if x, ok := m.GetStatement().(*GraphStatement_HasValue); ok {
		return x.HasValue
	}
	return nil
}

func (m *GraphStatement) GetIn() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_In); ok {
		return x.In
	}
	return nil
}

func (m *GraphStatement) GetOut() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Out); ok {
		return x.Out
	}
	return nil
}

func (m *GraphStatement) GetInEdge() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_InEdge); ok {
		return x.InEdge
	}
	return nil
}

func (m *GraphStatement) GetOutEdge() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_OutEdge); ok {
		return x.OutEdge
	}
	return nil
}

func (m *GraphStatement) GetBoth() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Both); ok {
		return x.Both
	}
	return nil
}

func (m *GraphStatement) GetBothEdge() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_BothEdge); ok {
		return x.BothEdge
	}
	return nil
}

func (m *GraphStatement) GetAs() string {
	if x, ok := m.GetStatement().(*GraphStatement_As); ok {
		return x.As
	}
	return ""
}

func (m *GraphStatement) GetSelect() *SelectStatement {
	if x, ok := m.GetStatement().(*GraphStatement_Select); ok {
		return x.Select
	}
	return nil
}

func (m *GraphStatement) GetValues() *SelectStatement {
	if x, ok := m.GetStatement().(*GraphStatement_Values); ok {
		return x.Values
	}
	return nil
}

func (m *GraphStatement) GetRender() *google_protobuf1.Value {
	if x, ok := m.GetStatement().(*GraphStatement_Render); ok {
		return x.Render
	}
	return nil
}

func (m *GraphStatement) GetLimit() int64 {
	if x, ok := m.GetStatement().(*GraphStatement_Limit); ok {
		return x.Limit
	}
	return 0
}

func (m *GraphStatement) GetCount() string {
	if x, ok := m.GetStatement().(*GraphStatement_Count); ok {
		return x.Count
	}
	return ""
}

func (m *GraphStatement) GetGroupCount() string {
	if x, ok := m.GetStatement().(*GraphStatement_GroupCount); ok {
		return x.GroupCount
	}
	return ""
}

func (m *GraphStatement) GetDistinct() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Distinct); ok {
		return x.Distinct
	}
	return nil
}

func (m *GraphStatement) GetMatch() *GraphQuerySet {
	if x, ok := m.GetStatement().(*GraphStatement_Match); ok {
		return x.Match
	}
	return nil
}

func (m *GraphStatement) GetImport() string {
	if x, ok := m.GetStatement().(*GraphStatement_Import); ok {
		return x.Import
	}
	return ""
}

func (m *GraphStatement) GetMap() string {
	if x, ok := m.GetStatement().(*GraphStatement_Map); ok {
		return x.Map
	}
	return ""
}

func (m *GraphStatement) GetFold() *FoldStatement {
	if x, ok := m.GetStatement().(*GraphStatement_Fold); ok {
		return x.Fold
	}
	return nil
}

func (m *GraphStatement) GetVertexFold() *FoldStatement {
	if x, ok := m.GetStatement().(*GraphStatement_VertexFold); ok {
		return x.VertexFold
	}
	return nil
}

func (m *GraphStatement) GetFilter() string {
	if x, ok := m.GetStatement().(*GraphStatement_Filter); ok {
		return x.Filter
	}
	return ""
}

func (m *GraphStatement) GetFilterValues() string {
	if x, ok := m.GetStatement().(*GraphStatement_FilterValues); ok {
		return x.FilterValues
	}
	return ""
}

func (m *GraphStatement) GetVertexFromValues() string {
	if x, ok := m.GetStatement().(*GraphStatement_VertexFromValues); ok {
		return x.VertexFromValues
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GraphStatement) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GraphStatement_OneofMarshaler, _GraphStatement_OneofUnmarshaler, _GraphStatement_OneofSizer, []interface{}{
		(*GraphStatement_V)(nil),
		(*GraphStatement_E)(nil),
		(*GraphStatement_Has)(nil),
		(*GraphStatement_HasLabel)(nil),
		(*GraphStatement_HasId)(nil),
		(*GraphStatement_HasValue)(nil),
		(*GraphStatement_In)(nil),
		(*GraphStatement_Out)(nil),
		(*GraphStatement_InEdge)(nil),
		(*GraphStatement_OutEdge)(nil),
		(*GraphStatement_Both)(nil),
		(*GraphStatement_BothEdge)(nil),
		(*GraphStatement_As)(nil),
		(*GraphStatement_Select)(nil),
		(*GraphStatement_Values)(nil),
		(*GraphStatement_Render)(nil),
		(*GraphStatement_Limit)(nil),
		(*GraphStatement_Count)(nil),
		(*GraphStatement_GroupCount)(nil),
		(*GraphStatement_Distinct)(nil),
		(*GraphStatement_Match)(nil),
		(*GraphStatement_Import)(nil),
		(*GraphStatement_Map)(nil),
		(*GraphStatement_Fold)(nil),
		(*GraphStatement_VertexFold)(nil),
		(*GraphStatement_Filter)(nil),
		(*GraphStatement_FilterValues)(nil),
		(*GraphStatement_VertexFromValues)(nil),
	}
}

func _GraphStatement_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GraphStatement)
	// statement
	switch x := m.Statement.(type) {
	case *GraphStatement_V:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V); err != nil {
			return err
		}
	case *GraphStatement_E:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.E); err != nil {
			return err
		}
	case *GraphStatement_Has:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Has); err != nil {
			return err
		}
	case *GraphStatement_HasLabel:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HasLabel); err != nil {
			return err
		}
	case *GraphStatement_HasId:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HasId); err != nil {
			return err
		}
	case *GraphStatement_HasValue:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HasValue); err != nil {
			return err
		}
	case *GraphStatement_In:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.In); err != nil {
			return err
		}
	case *GraphStatement_Out:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Out); err != nil {
			return err
		}
	case *GraphStatement_InEdge:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InEdge); err != nil {
			return err
		}
	case *GraphStatement_OutEdge:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OutEdge); err != nil {
			return err
		}
	case *GraphStatement_Both:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Both); err != nil {
			return err
		}
	case *GraphStatement_BothEdge:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BothEdge); err != nil {
			return err
		}
	case *GraphStatement_As:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.As)
	case *GraphStatement_Select:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Select); err != nil {
			return err
		}
	case *GraphStatement_Values:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Values); err != nil {
			return err
		}
	case *GraphStatement_Render:
		b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Render); err != nil {
			return err
		}
	case *GraphStatement_Limit:
		b.EncodeVarint(25<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Limit))
	case *GraphStatement_Count:
		b.EncodeVarint(26<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Count)
	case *GraphStatement_GroupCount:
		b.EncodeVarint(30<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.GroupCount)
	case *GraphStatement_Distinct:
		b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Distinct); err != nil {
			return err
		}
	case *GraphStatement_Match:
		b.EncodeVarint(40<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Match); err != nil {
			return err
		}
	case *GraphStatement_Import:
		b.EncodeVarint(50<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Import)
	case *GraphStatement_Map:
		b.EncodeVarint(51<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Map)
	case *GraphStatement_Fold:
		b.EncodeVarint(52<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fold); err != nil {
			return err
		}
	case *GraphStatement_VertexFold:
		b.EncodeVarint(53<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VertexFold); err != nil {
			return err
		}
	case *GraphStatement_Filter:
		b.EncodeVarint(54<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Filter)
	case *GraphStatement_FilterValues:
		b.EncodeVarint(55<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.FilterValues)
	case *GraphStatement_VertexFromValues:
		b.EncodeVarint(56<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.VertexFromValues)
	case nil:
	default:
		return fmt.Errorf("GraphStatement.Statement has unexpected type %T", x)
	}
	return nil
}

func _GraphStatement_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GraphStatement)
	switch tag {
	case 1: // statement.v
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_V{msg}
		return true, err
	case 2: // statement.e
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_E{msg}
		return true, err
	case 5: // statement.has
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HasStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Has{msg}
		return true, err
	case 6: // statement.has_label
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_HasLabel{msg}
		return true, err
	case 7: // statement.has_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_HasId{msg}
		return true, err
	case 8: // statement.has_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HasValueStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_HasValue{msg}
		return true, err
	case 10: // statement.in
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_In{msg}
		return true, err
	case 11: // statement.out
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Out{msg}
		return true, err
	case 12: // statement.in_edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_InEdge{msg}
		return true, err
	case 13: // statement.out_edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_OutEdge{msg}
		return true, err
	case 14: // statement.both
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Both{msg}
		return true, err
	case 15: // statement.both_edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_BothEdge{msg}
		return true, err
	case 20: // statement.as
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_As{x}
		return true, err
	case 21: // statement.select
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SelectStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Select{msg}
		return true, err
	case 22: // statement.values
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SelectStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Values{msg}
		return true, err
	case 23: // statement.render
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Value)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Render{msg}
		return true, err
	case 25: // statement.limit
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Statement = &GraphStatement_Limit{int64(x)}
		return true, err
	case 26: // statement.count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_Count{x}
		return true, err
	case 30: // statement.group_count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_GroupCount{x}
		return true, err
	case 31: // statement.distinct
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Distinct{msg}
		return true, err
	case 40: // statement.match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuerySet)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Match{msg}
		return true, err
	case 50: // statement.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_Import{x}
		return true, err
	case 51: // statement.map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_Map{x}
		return true, err
	case 52: // statement.fold
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FoldStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Fold{msg}
		return true, err
	case 53: // statement.vertex_fold
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FoldStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_VertexFold{msg}
		return true, err
	case 54: // statement.filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_Filter{x}
		return true, err
	case 55: // statement.filter_values
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_FilterValues{x}
		return true, err
	case 56: // statement.vertex_from_values
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_VertexFromValues{x}
		return true, err
	default:
		return false, nil
	}
}

func _GraphStatement_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GraphStatement)
	// statement
	switch x := m.Statement.(type) {
	case *GraphStatement_V:
		s := proto.Size(x.V)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_E:
		s := proto.Size(x.E)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Has:
		s := proto.Size(x.Has)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_HasLabel:
		s := proto.Size(x.HasLabel)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_HasId:
		s := proto.Size(x.HasId)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_HasValue:
		s := proto.Size(x.HasValue)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_In:
		s := proto.Size(x.In)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Out:
		s := proto.Size(x.Out)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_InEdge:
		s := proto.Size(x.InEdge)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_OutEdge:
		s := proto.Size(x.OutEdge)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Both:
		s := proto.Size(x.Both)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_BothEdge:
		s := proto.Size(x.BothEdge)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_As:
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.As)))
		n += len(x.As)
	case *GraphStatement_Select:
		s := proto.Size(x.Select)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Values:
		s := proto.Size(x.Values)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Render:
		s := proto.Size(x.Render)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Limit:
		n += proto.SizeVarint(25<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Limit))
	case *GraphStatement_Count:
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Count)))
		n += len(x.Count)
	case *GraphStatement_GroupCount:
		n += proto.SizeVarint(30<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.GroupCount)))
		n += len(x.GroupCount)
	case *GraphStatement_Distinct:
		s := proto.Size(x.Distinct)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Match:
		s := proto.Size(x.Match)
		n += proto.SizeVarint(40<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Import:
		n += proto.SizeVarint(50<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Import)))
		n += len(x.Import)
	case *GraphStatement_Map:
		n += proto.SizeVarint(51<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Map)))
		n += len(x.Map)
	case *GraphStatement_Fold:
		s := proto.Size(x.Fold)
		n += proto.SizeVarint(52<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_VertexFold:
		s := proto.Size(x.VertexFold)
		n += proto.SizeVarint(53<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Filter:
		n += proto.SizeVarint(54<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Filter)))
		n += len(x.Filter)
	case *GraphStatement_FilterValues:
		n += proto.SizeVarint(55<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.FilterValues)))
		n += len(x.FilterValues)
	case *GraphStatement_VertexFromValues:
		n += proto.SizeVarint(56<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.VertexFromValues)))
		n += len(x.VertexFromValues)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HasStatement struct {
	Key    string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Within []string `protobuf:"bytes,2,rep,name=within" json:"within,omitempty"`
}

func (m *HasStatement) Reset()                    { *m = HasStatement{} }
func (m *HasStatement) String() string            { return proto.CompactTextString(m) }
func (*HasStatement) ProtoMessage()               {}
func (*HasStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *HasStatement) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HasStatement) GetWithin() []string {
	if m != nil {
		return m.Within
	}
	return nil
}

type HasValueStatement struct {
	Key1      string    `protobuf:"bytes,1,opt,name=key1" json:"key1,omitempty"`
	Key2      string    `protobuf:"bytes,2,opt,name=key2" json:"key2,omitempty"`
	Condition Condition `protobuf:"varint,3,opt,name=condition,enum=aql.Condition" json:"condition,omitempty"`
}

func (m *HasValueStatement) Reset()                    { *m = HasValueStatement{} }
func (m *HasValueStatement) String() string            { return proto.CompactTextString(m) }
func (*HasValueStatement) ProtoMessage()               {}
func (*HasValueStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *HasValueStatement) GetKey1() string {
	if m != nil {
		return m.Key1
	}
	return ""
}

func (m *HasValueStatement) GetKey2() string {
	if m != nil {
		return m.Key2
	}
	return ""
}

func (m *HasValueStatement) GetCondition() Condition {
	if m != nil {
		return m.Condition
	}
	return Condition_UNKNOWN_CONDITION
}

type SelectStatement struct {
	Labels []string `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty"`
}

func (m *SelectStatement) Reset()                    { *m = SelectStatement{} }
func (m *SelectStatement) String() string            { return proto.CompactTextString(m) }
func (*SelectStatement) ProtoMessage()               {}
func (*SelectStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SelectStatement) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type FoldStatement struct {
	Source string                  `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Init   *google_protobuf1.Value `protobuf:"bytes,2,opt,name=init" json:"init,omitempty"`
}

func (m *FoldStatement) Reset()                    { *m = FoldStatement{} }
func (m *FoldStatement) String() string            { return proto.CompactTextString(m) }
func (*FoldStatement) ProtoMessage()               {}
func (*FoldStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FoldStatement) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *FoldStatement) GetInit() *google_protobuf1.Value {
	if m != nil {
		return m.Init
	}
	return nil
}

type Vertex struct {
	Gid   string                   `protobuf:"bytes,1,opt,name=gid" json:"gid,omitempty"`
	Label string                   `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Data  *google_protobuf1.Struct `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Vertex) Reset()                    { *m = Vertex{} }
func (m *Vertex) String() string            { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()               {}
func (*Vertex) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Vertex) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *Vertex) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Vertex) GetData() *google_protobuf1.Struct {
	if m != nil {
		return m.Data
	}
	return nil
}

type Edge struct {
	Gid   string                   `protobuf:"bytes,1,opt,name=gid" json:"gid,omitempty"`
	Label string                   `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	From  string                   `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
	To    string                   `protobuf:"bytes,4,opt,name=to" json:"to,omitempty"`
	Data  *google_protobuf1.Struct `protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
}

func (m *Edge) Reset()                    { *m = Edge{} }
func (m *Edge) String() string            { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()               {}
func (*Edge) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Edge) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *Edge) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Edge) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Edge) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Edge) GetData() *google_protobuf1.Struct {
	if m != nil {
		return m.Data
	}
	return nil
}

type QueryResult struct {
	// Types that are valid to be assigned to Result:
	//	*QueryResult_Vertex
	//	*QueryResult_Edge
	//	*QueryResult_Data
	Result isQueryResult_Result `protobuf_oneof:"result"`
}

func (m *QueryResult) Reset()                    { *m = QueryResult{} }
func (m *QueryResult) String() string            { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()               {}
func (*QueryResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isQueryResult_Result interface {
	isQueryResult_Result()
}

type QueryResult_Vertex struct {
	Vertex *Vertex `protobuf:"bytes,1,opt,name=vertex,oneof"`
}
type QueryResult_Edge struct {
	Edge *Edge `protobuf:"bytes,2,opt,name=edge,oneof"`
}
type QueryResult_Data struct {
	Data *google_protobuf1.Value `protobuf:"bytes,4,opt,name=data,oneof"`
}

func (*QueryResult_Vertex) isQueryResult_Result() {}
func (*QueryResult_Edge) isQueryResult_Result()   {}
func (*QueryResult_Data) isQueryResult_Result()   {}

func (m *QueryResult) GetResult() isQueryResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryResult) GetVertex() *Vertex {
	if x, ok := m.GetResult().(*QueryResult_Vertex); ok {
		return x.Vertex
	}
	return nil
}

func (m *QueryResult) GetEdge() *Edge {
	if x, ok := m.GetResult().(*QueryResult_Edge); ok {
		return x.Edge
	}
	return nil
}

func (m *QueryResult) GetData() *google_protobuf1.Value {
	if x, ok := m.GetResult().(*QueryResult_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryResult_OneofMarshaler, _QueryResult_OneofUnmarshaler, _QueryResult_OneofSizer, []interface{}{
		(*QueryResult_Vertex)(nil),
		(*QueryResult_Edge)(nil),
		(*QueryResult_Data)(nil),
	}
}

func _QueryResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryResult)
	// result
	switch x := m.Result.(type) {
	case *QueryResult_Vertex:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vertex); err != nil {
			return err
		}
	case *QueryResult_Edge:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Edge); err != nil {
			return err
		}
	case *QueryResult_Data:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QueryResult.Result has unexpected type %T", x)
	}
	return nil
}

func _QueryResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryResult)
	switch tag {
	case 1: // result.vertex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Vertex)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Vertex{msg}
		return true, err
	case 2: // result.edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Edge)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Edge{msg}
		return true, err
	case 4: // result.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Value)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Data{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QueryResult_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryResult)
	// result
	switch x := m.Result.(type) {
	case *QueryResult_Vertex:
		s := proto.Size(x.Vertex)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Edge:
		s := proto.Size(x.Edge)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Data:
		s := proto.Size(x.Data)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ResultRow struct {
	Value *QueryResult   `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	Row   []*QueryResult `protobuf:"bytes,2,rep,name=row" json:"row,omitempty"`
}

func (m *ResultRow) Reset()                    { *m = ResultRow{} }
func (m *ResultRow) String() string            { return proto.CompactTextString(m) }
func (*ResultRow) ProtoMessage()               {}
func (*ResultRow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ResultRow) GetValue() *QueryResult {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ResultRow) GetRow() []*QueryResult {
	if m != nil {
		return m.Row
	}
	return nil
}

type EditResult struct {
	// Types that are valid to be assigned to Result:
	//	*EditResult_Error
	//	*EditResult_Id
	Result isEditResult_Result `protobuf_oneof:"result"`
}

func (m *EditResult) Reset()                    { *m = EditResult{} }
func (m *EditResult) String() string            { return proto.CompactTextString(m) }
func (*EditResult) ProtoMessage()               {}
func (*EditResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isEditResult_Result interface {
	isEditResult_Result()
}

type EditResult_Error struct {
	Error string `protobuf:"bytes,1,opt,name=error,oneof"`
}
type EditResult_Id struct {
	Id string `protobuf:"bytes,2,opt,name=id,oneof"`
}

func (*EditResult_Error) isEditResult_Result() {}
func (*EditResult_Id) isEditResult_Result()    {}

func (m *EditResult) GetResult() isEditResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *EditResult) GetError() string {
	if x, ok := m.GetResult().(*EditResult_Error); ok {
		return x.Error
	}
	return ""
}

func (m *EditResult) GetId() string {
	if x, ok := m.GetResult().(*EditResult_Id); ok {
		return x.Id
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EditResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EditResult_OneofMarshaler, _EditResult_OneofUnmarshaler, _EditResult_OneofSizer, []interface{}{
		(*EditResult_Error)(nil),
		(*EditResult_Id)(nil),
	}
}

func _EditResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EditResult)
	// result
	switch x := m.Result.(type) {
	case *EditResult_Error:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Error)
	case *EditResult_Id:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Id)
	case nil:
	default:
		return fmt.Errorf("EditResult.Result has unexpected type %T", x)
	}
	return nil
}

func _EditResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EditResult)
	switch tag {
	case 1: // result.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &EditResult_Error{x}
		return true, err
	case 2: // result.id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &EditResult_Id{x}
		return true, err
	default:
		return false, nil
	}
}

func _EditResult_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EditResult)
	// result
	switch x := m.Result.(type) {
	case *EditResult_Error:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Error)))
		n += len(x.Error)
	case *EditResult_Id:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GraphElement struct {
	Graph  string  `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Vertex *Vertex `protobuf:"bytes,2,opt,name=vertex" json:"vertex,omitempty"`
	Edge   *Edge   `protobuf:"bytes,3,opt,name=edge" json:"edge,omitempty"`
}

func (m *GraphElement) Reset()                    { *m = GraphElement{} }
func (m *GraphElement) String() string            { return proto.CompactTextString(m) }
func (*GraphElement) ProtoMessage()               {}
func (*GraphElement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GraphElement) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *GraphElement) GetVertex() *Vertex {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *GraphElement) GetEdge() *Edge {
	if m != nil {
		return m.Edge
	}
	return nil
}

type Graph struct {
	Graph    string    `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Edges    []*Edge   `protobuf:"bytes,2,rep,name=edges" json:"edges,omitempty"`
	Vertices []*Vertex `protobuf:"bytes,3,rep,name=vertices" json:"vertices,omitempty"`
}

func (m *Graph) Reset()                    { *m = Graph{} }
func (m *Graph) String() string            { return proto.CompactTextString(m) }
func (*Graph) ProtoMessage()               {}
func (*Graph) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Graph) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *Graph) GetEdges() []*Edge {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *Graph) GetVertices() []*Vertex {
	if m != nil {
		return m.Vertices
	}
	return nil
}

type GraphID struct {
	Graph string `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
}

func (m *GraphID) Reset()                    { *m = GraphID{} }
func (m *GraphID) String() string            { return proto.CompactTextString(m) }
func (*GraphID) ProtoMessage()               {}
func (*GraphID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GraphID) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

type ElementID struct {
	Graph string `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Id    string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *ElementID) Reset()                    { *m = ElementID{} }
func (m *ElementID) String() string            { return proto.CompactTextString(m) }
func (*ElementID) ProtoMessage()               {}
func (*ElementID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ElementID) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *ElementID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type IndexID struct {
	Graph string      `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Label string      `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Field string      `protobuf:"bytes,3,opt,name=field" json:"field,omitempty"`
	Type  ElementType `protobuf:"varint,4,opt,name=type,enum=aql.ElementType" json:"type,omitempty"`
}

func (m *IndexID) Reset()                    { *m = IndexID{} }
func (m *IndexID) String() string            { return proto.CompactTextString(m) }
func (*IndexID) ProtoMessage()               {}
func (*IndexID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *IndexID) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *IndexID) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *IndexID) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *IndexID) GetType() ElementType {
	if m != nil {
		return m.Type
	}
	return ElementType_UNKNOWN_TYPE
}

type IndexQuery struct {
	Graph string            `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Label string            `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Field string            `protobuf:"bytes,3,opt,name=field" json:"field,omitempty"`
	Type  ElementType       `protobuf:"varint,4,opt,name=type,enum=aql.ElementType" json:"type,omitempty"`
	Query []*GraphStatement `protobuf:"bytes,5,rep,name=query" json:"query,omitempty"`
}

func (m *IndexQuery) Reset()                    { *m = IndexQuery{} }
func (m *IndexQuery) String() string            { return proto.CompactTextString(m) }
func (*IndexQuery) ProtoMessage()               {}
func (*IndexQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *IndexQuery) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *IndexQuery) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *IndexQuery) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *IndexQuery) GetType() ElementType {
	if m != nil {
		return m.Type
	}
	return ElementType_UNKNOWN_TYPE
}

func (m *IndexQuery) GetQuery() []*GraphStatement {
	if m != nil {
		return m.Query
	}
	return nil
}

type IndexTermCount struct {
	Term  *google_protobuf1.Value `protobuf:"bytes,1,opt,name=term" json:"term,omitempty"`
	Count int32                   `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
}

func (m *IndexTermCount) Reset()                    { *m = IndexTermCount{} }
func (m *IndexTermCount) String() string            { return proto.CompactTextString(m) }
func (*IndexTermCount) ProtoMessage()               {}
func (*IndexTermCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *IndexTermCount) GetTerm() *google_protobuf1.Value {
	if m != nil {
		return m.Term
	}
	return nil
}

func (m *IndexTermCount) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Timestamp struct {
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Timestamp) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func init() {
	proto.RegisterType((*GraphQuery)(nil), "aql.GraphQuery")
	proto.RegisterType((*GraphQuerySet)(nil), "aql.GraphQuerySet")
	proto.RegisterType((*GraphStatement)(nil), "aql.GraphStatement")
	proto.RegisterType((*HasStatement)(nil), "aql.HasStatement")
	proto.RegisterType((*HasValueStatement)(nil), "aql.HasValueStatement")
	proto.RegisterType((*SelectStatement)(nil), "aql.SelectStatement")
	proto.RegisterType((*FoldStatement)(nil), "aql.FoldStatement")
	proto.RegisterType((*Vertex)(nil), "aql.Vertex")
	proto.RegisterType((*Edge)(nil), "aql.Edge")
	proto.RegisterType((*QueryResult)(nil), "aql.QueryResult")
	proto.RegisterType((*ResultRow)(nil), "aql.ResultRow")
	proto.RegisterType((*EditResult)(nil), "aql.EditResult")
	proto.RegisterType((*GraphElement)(nil), "aql.GraphElement")
	proto.RegisterType((*Graph)(nil), "aql.Graph")
	proto.RegisterType((*GraphID)(nil), "aql.GraphID")
	proto.RegisterType((*ElementID)(nil), "aql.ElementID")
	proto.RegisterType((*IndexID)(nil), "aql.IndexID")
	proto.RegisterType((*IndexQuery)(nil), "aql.IndexQuery")
	proto.RegisterType((*IndexTermCount)(nil), "aql.IndexTermCount")
	proto.RegisterType((*Timestamp)(nil), "aql.Timestamp")
	proto.RegisterType((*Empty)(nil), "aql.Empty")
	proto.RegisterEnum("aql.Condition", Condition_name, Condition_value)
	proto.RegisterEnum("aql.ElementType", ElementType_name, ElementType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Query service

type QueryClient interface {
	Traversal(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Query_TraversalClient, error)
	GetVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Vertex, error)
	GetEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Edge, error)
	GetGraphs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Query_GetGraphsClient, error)
	GetIndexList(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (Query_GetIndexListClient, error)
	GetIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (Query_GetIndexClient, error)
	IndexTraversal(ctx context.Context, in *IndexQuery, opts ...grpc.CallOption) (Query_IndexTraversalClient, error)
	GetTimestamp(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Timestamp, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Traversal(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Query_TraversalClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[0], c.cc, "/aql.Query/Traversal", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryTraversalClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_TraversalClient interface {
	Recv() (*ResultRow, error)
	grpc.ClientStream
}

type queryTraversalClient struct {
	grpc.ClientStream
}

func (x *queryTraversalClient) Recv() (*ResultRow, error) {
	m := new(ResultRow)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) GetVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Vertex, error) {
	out := new(Vertex)
	err := grpc.Invoke(ctx, "/aql.Query/GetVertex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Edge, error) {
	out := new(Edge)
	err := grpc.Invoke(ctx, "/aql.Query/GetEdge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetGraphs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Query_GetGraphsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[1], c.cc, "/aql.Query/GetGraphs", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryGetGraphsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_GetGraphsClient interface {
	Recv() (*ElementID, error)
	grpc.ClientStream
}

type queryGetGraphsClient struct {
	grpc.ClientStream
}

func (x *queryGetGraphsClient) Recv() (*ElementID, error) {
	m := new(ElementID)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) GetIndexList(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (Query_GetIndexListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[2], c.cc, "/aql.Query/GetIndexList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryGetIndexListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_GetIndexListClient interface {
	Recv() (*IndexID, error)
	grpc.ClientStream
}

type queryGetIndexListClient struct {
	grpc.ClientStream
}

func (x *queryGetIndexListClient) Recv() (*IndexID, error) {
	m := new(IndexID)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) GetIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (Query_GetIndexClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[3], c.cc, "/aql.Query/GetIndex", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryGetIndexClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_GetIndexClient interface {
	Recv() (*IndexTermCount, error)
	grpc.ClientStream
}

type queryGetIndexClient struct {
	grpc.ClientStream
}

func (x *queryGetIndexClient) Recv() (*IndexTermCount, error) {
	m := new(IndexTermCount)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) IndexTraversal(ctx context.Context, in *IndexQuery, opts ...grpc.CallOption) (Query_IndexTraversalClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[4], c.cc, "/aql.Query/IndexTraversal", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryIndexTraversalClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_IndexTraversalClient interface {
	Recv() (*ResultRow, error)
	grpc.ClientStream
}

type queryIndexTraversalClient struct {
	grpc.ClientStream
}

func (x *queryIndexTraversalClient) Recv() (*ResultRow, error) {
	m := new(ResultRow)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) GetTimestamp(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Timestamp, error) {
	out := new(Timestamp)
	err := grpc.Invoke(ctx, "/aql.Query/GetTimestamp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Query service

type QueryServer interface {
	Traversal(*GraphQuery, Query_TraversalServer) error
	GetVertex(context.Context, *ElementID) (*Vertex, error)
	GetEdge(context.Context, *ElementID) (*Edge, error)
	GetGraphs(*Empty, Query_GetGraphsServer) error
	GetIndexList(*GraphID, Query_GetIndexListServer) error
	GetIndex(*IndexID, Query_GetIndexServer) error
	IndexTraversal(*IndexQuery, Query_IndexTraversalServer) error
	GetTimestamp(context.Context, *ElementID) (*Timestamp, error)
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Traversal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).Traversal(m, &queryTraversalServer{stream})
}

type Query_TraversalServer interface {
	Send(*ResultRow) error
	grpc.ServerStream
}

type queryTraversalServer struct {
	grpc.ServerStream
}

func (x *queryTraversalServer) Send(m *ResultRow) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_GetVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/GetVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetVertex(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/GetEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetEdge(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetGraphs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).GetGraphs(m, &queryGetGraphsServer{stream})
}

type Query_GetGraphsServer interface {
	Send(*ElementID) error
	grpc.ServerStream
}

type queryGetGraphsServer struct {
	grpc.ServerStream
}

func (x *queryGetGraphsServer) Send(m *ElementID) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_GetIndexList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).GetIndexList(m, &queryGetIndexListServer{stream})
}

type Query_GetIndexListServer interface {
	Send(*IndexID) error
	grpc.ServerStream
}

type queryGetIndexListServer struct {
	grpc.ServerStream
}

func (x *queryGetIndexListServer) Send(m *IndexID) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_GetIndex_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).GetIndex(m, &queryGetIndexServer{stream})
}

type Query_GetIndexServer interface {
	Send(*IndexTermCount) error
	grpc.ServerStream
}

type queryGetIndexServer struct {
	grpc.ServerStream
}

func (x *queryGetIndexServer) Send(m *IndexTermCount) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_IndexTraversal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).IndexTraversal(m, &queryIndexTraversalServer{stream})
}

type Query_IndexTraversalServer interface {
	Send(*ResultRow) error
	grpc.ServerStream
}

type queryIndexTraversalServer struct {
	grpc.ServerStream
}

func (x *queryIndexTraversalServer) Send(m *ResultRow) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_GetTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/GetTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetTimestamp(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aql.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVertex",
			Handler:    _Query_GetVertex_Handler,
		},
		{
			MethodName: "GetEdge",
			Handler:    _Query_GetEdge_Handler,
		},
		{
			MethodName: "GetTimestamp",
			Handler:    _Query_GetTimestamp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Traversal",
			Handler:       _Query_Traversal_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetGraphs",
			Handler:       _Query_GetGraphs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetIndexList",
			Handler:       _Query_GetIndexList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetIndex",
			Handler:       _Query_GetIndex_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexTraversal",
			Handler:       _Query_IndexTraversal_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aql.proto",
}

// Client API for Edit service

type EditClient interface {
	AddVertex(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error)
	AddEdge(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error)
	StreamElements(ctx context.Context, opts ...grpc.CallOption) (Edit_StreamElementsClient, error)
	AddGraph(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	AddSubGraph(ctx context.Context, in *Graph, opts ...grpc.CallOption) (*EditResult, error)
	DeleteGraph(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	AddIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error)
}

type editClient struct {
	cc *grpc.ClientConn
}

func NewEditClient(cc *grpc.ClientConn) EditClient {
	return &editClient{cc}
}

func (c *editClient) AddVertex(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddVertex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddEdge(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddEdge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) StreamElements(ctx context.Context, opts ...grpc.CallOption) (Edit_StreamElementsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Edit_serviceDesc.Streams[0], c.cc, "/aql.Edit/StreamElements", opts...)
	if err != nil {
		return nil, err
	}
	x := &editStreamElementsClient{stream}
	return x, nil
}

type Edit_StreamElementsClient interface {
	Send(*GraphElement) error
	CloseAndRecv() (*EditResult, error)
	grpc.ClientStream
}

type editStreamElementsClient struct {
	grpc.ClientStream
}

func (x *editStreamElementsClient) Send(m *GraphElement) error {
	return x.ClientStream.SendMsg(m)
}

func (x *editStreamElementsClient) CloseAndRecv() (*EditResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EditResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *editClient) AddGraph(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddSubGraph(ctx context.Context, in *Graph, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddSubGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteGraph(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteVertex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteEdge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Edit service

type EditServer interface {
	AddVertex(context.Context, *GraphElement) (*EditResult, error)
	AddEdge(context.Context, *GraphElement) (*EditResult, error)
	StreamElements(Edit_StreamElementsServer) error
	AddGraph(context.Context, *ElementID) (*EditResult, error)
	AddSubGraph(context.Context, *Graph) (*EditResult, error)
	DeleteGraph(context.Context, *ElementID) (*EditResult, error)
	DeleteVertex(context.Context, *ElementID) (*EditResult, error)
	DeleteEdge(context.Context, *ElementID) (*EditResult, error)
	AddIndex(context.Context, *IndexID) (*EditResult, error)
	DeleteIndex(context.Context, *IndexID) (*EditResult, error)
}

func RegisterEditServer(s *grpc.Server, srv EditServer) {
	s.RegisterService(&_Edit_serviceDesc, srv)
}

func _Edit_AddVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddVertex(ctx, req.(*GraphElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddEdge(ctx, req.(*GraphElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_StreamElements_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EditServer).StreamElements(&editStreamElementsServer{stream})
}

type Edit_StreamElementsServer interface {
	SendAndClose(*EditResult) error
	Recv() (*GraphElement, error)
	grpc.ServerStream
}

type editStreamElementsServer struct {
	grpc.ServerStream
}

func (x *editStreamElementsServer) SendAndClose(m *EditResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *editStreamElementsServer) Recv() (*GraphElement, error) {
	m := new(GraphElement)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Edit_AddGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddGraph(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddSubGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Graph)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddSubGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddSubGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddSubGraph(ctx, req.(*Graph))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteGraph(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteVertex(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteEdge(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddIndex(ctx, req.(*IndexID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteIndex(ctx, req.(*IndexID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Edit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aql.Edit",
	HandlerType: (*EditServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddVertex",
			Handler:    _Edit_AddVertex_Handler,
		},
		{
			MethodName: "AddEdge",
			Handler:    _Edit_AddEdge_Handler,
		},
		{
			MethodName: "AddGraph",
			Handler:    _Edit_AddGraph_Handler,
		},
		{
			MethodName: "AddSubGraph",
			Handler:    _Edit_AddSubGraph_Handler,
		},
		{
			MethodName: "DeleteGraph",
			Handler:    _Edit_DeleteGraph_Handler,
		},
		{
			MethodName: "DeleteVertex",
			Handler:    _Edit_DeleteVertex_Handler,
		},
		{
			MethodName: "DeleteEdge",
			Handler:    _Edit_DeleteEdge_Handler,
		},
		{
			MethodName: "AddIndex",
			Handler:    _Edit_AddIndex_Handler,
		},
		{
			MethodName: "DeleteIndex",
			Handler:    _Edit_DeleteIndex_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamElements",
			Handler:       _Edit_StreamElements_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aql.proto",
}

func init() { proto.RegisterFile("aql.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1739 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x73, 0x13, 0xc9,
	0x15, 0x67, 0x24, 0x8d, 0xa4, 0x79, 0x32, 0x66, 0xfc, 0x60, 0xcd, 0xa0, 0xc0, 0x9a, 0xf4, 0x42,
	0xd6, 0x56, 0x28, 0xcb, 0x88, 0x38, 0x4b, 0x5c, 0x39, 0x04, 0xf0, 0xac, 0x51, 0x85, 0x95, 0xc3,
	0x48, 0x98, 0xec, 0x61, 0xcb, 0x19, 0x7b, 0x1a, 0x69, 0x6a, 0x25, 0x8d, 0x98, 0x69, 0x19, 0x5c,
	0x14, 0x95, 0xaa, 0xdc, 0x73, 0x4a, 0xee, 0xb9, 0xe4, 0xcb, 0xe4, 0x9c, 0x63, 0xae, 0xf9, 0x20,
	0xa9, 0x7e, 0xdd, 0x23, 0x09, 0xc9, 0x32, 0x93, 0xaa, 0x3d, 0x49, 0xef, 0xf5, 0xef, 0xfd, 0xde,
	0xeb, 0xf7, 0xaf, 0x07, 0x2c, 0xff, 0x6d, 0x7f, 0x7b, 0x14, 0x47, 0x22, 0xc2, 0xbc, 0xff, 0xb6,
	0x5f, 0xbd, 0xdd, 0x8d, 0xa2, 0x6e, 0x9f, 0xd7, 0xfd, 0x51, 0x58, 0xf7, 0x87, 0xc3, 0x48, 0xf8,
	0x22, 0x8c, 0x86, 0x89, 0x82, 0x4c, 0x4e, 0x49, 0x3a, 0x19, 0xbf, 0xa9, 0x27, 0x22, 0x1e, 0x9f,
	0x0a, 0x75, 0xca, 0xbe, 0x03, 0x38, 0x88, 0xfd, 0x51, 0xef, 0xe5, 0x98, 0xc7, 0xe7, 0x78, 0x03,
	0xcc, 0xae, 0x94, 0x1c, 0xe3, 0xae, 0xb1, 0x69, 0x79, 0x4a, 0xc0, 0x2d, 0x30, 0xdf, 0xca, 0x63,
	0x27, 0x77, 0x37, 0xbf, 0x59, 0x69, 0x5c, 0xdf, 0x96, 0xfe, 0xc9, 0xaa, 0x2d, 0x7c, 0xc1, 0x07,
	0x7c, 0x28, 0x3c, 0x85, 0x60, 0x7b, 0x70, 0x75, 0x4a, 0xd7, 0xe6, 0x02, 0xb7, 0xa0, 0x24, 0x4f,
	0x42, 0x9e, 0x38, 0x06, 0x59, 0x5f, 0x9b, 0x5a, 0x13, 0xc8, 0x4b, 0xcf, 0xd9, 0x7f, 0x2c, 0x58,
	0xfd, 0x94, 0x15, 0x6b, 0x60, 0x9c, 0x51, 0x2c, 0x95, 0x46, 0x75, 0x5b, 0xdd, 0x63, 0x3b, 0xbd,
	0xc7, 0xf6, 0x8b, 0x30, 0x11, 0x47, 0x7e, 0x7f, 0xcc, 0x9f, 0x5f, 0xf1, 0x8c, 0x33, 0x89, 0xe5,
	0x4e, 0x2e, 0x0b, 0x96, 0xe3, 0x7d, 0xc8, 0xf7, 0xfc, 0xc4, 0x31, 0x09, 0xbd, 0x46, 0x11, 0x3d,
	0xf7, 0x93, 0x89, 0xdf, 0xe7, 0x57, 0x3c, 0x79, 0x8e, 0xbf, 0x01, 0xab, 0xe7, 0x27, 0xc7, 0x7d,
	0xff, 0x84, 0xf7, 0x9d, 0x62, 0x06, 0xea, 0x72, 0xcf, 0x4f, 0x5e, 0x48, 0x34, 0x3e, 0x82, 0xa2,
	0x34, 0x0d, 0x03, 0xa7, 0x94, 0xc1, 0xce, 0xec, 0xf9, 0x49, 0x33, 0xc0, 0x5d, 0xe5, 0xef, 0x4c,
	0x6a, 0x9d, 0x32, 0xd9, 0xad, 0xa7, 0xc1, 0x11, 0x74, 0x36, 0x42, 0xe9, 0x8b, 0x94, 0xf8, 0x00,
	0x72, 0xe1, 0xd0, 0x81, 0x0c, 0x7e, 0x72, 0xe1, 0x10, 0xb7, 0x21, 0x1f, 0x8d, 0x85, 0x53, 0xc9,
	0x00, 0x97, 0x40, 0xdc, 0x85, 0x52, 0x38, 0x3c, 0xe6, 0x41, 0x97, 0x3b, 0x2b, 0x19, 0x6c, 0x8a,
	0xe1, 0xd0, 0x0d, 0xba, 0x1c, 0xbf, 0x81, 0x72, 0x34, 0x16, 0xca, 0xee, 0x6a, 0x06, 0xbb, 0x52,
	0x34, 0x16, 0x64, 0xb8, 0x03, 0x85, 0x93, 0x48, 0xf4, 0x9c, 0xd5, 0x0c, 0x46, 0x84, 0x94, 0x65,
	0x92, 0xbf, 0xca, 0xd7, 0xb5, 0x2c, 0x65, 0x92, 0x70, 0x72, 0x66, 0x43, 0xce, 0x4f, 0x9c, 0x1b,
	0xb2, 0xdb, 0x65, 0x7a, 0xfc, 0x04, 0xb7, 0xa1, 0x98, 0xf0, 0x3e, 0x3f, 0x15, 0xce, 0x17, 0xc4,
	0x74, 0x83, 0x0a, 0xd0, 0x26, 0xd5, 0x6c, 0xfa, 0x35, 0x4a, 0xe2, 0xa9, 0x5e, 0x89, 0xb3, 0x7e,
	0x39, 0x5e, 0xa1, 0x70, 0x07, 0x8a, 0x31, 0x1f, 0x06, 0x3c, 0x76, 0x6e, 0xea, 0x02, 0xcf, 0x47,
	0x3a, 0xc9, 0xa4, 0xc2, 0xe1, 0x3a, 0x98, 0xfd, 0x70, 0x10, 0x0a, 0xe7, 0xd6, 0x5d, 0x63, 0x33,
	0x2f, 0xbb, 0x85, 0x44, 0xa9, 0x3f, 0x8d, 0xc6, 0x43, 0xe1, 0x54, 0x75, 0xf8, 0x4a, 0xc4, 0x9f,
	0x43, 0xa5, 0x1b, 0x47, 0xe3, 0xd1, 0xb1, 0x3a, 0xfd, 0x52, 0x9f, 0x02, 0x29, 0x9f, 0x11, 0xe4,
	0x31, 0x94, 0x83, 0x30, 0x11, 0xe1, 0xf0, 0x54, 0x38, 0x1b, 0x59, 0x12, 0x96, 0xa2, 0xb1, 0x06,
	0xe6, 0xc0, 0x17, 0xa7, 0x3d, 0x67, 0x93, 0xcc, 0x70, 0x6e, 0x9a, 0xdb, 0x5c, 0xde, 0x55, 0x41,
	0xd0, 0x81, 0x62, 0x38, 0x18, 0x45, 0xb1, 0x70, 0x1a, 0x3a, 0x06, 0x2d, 0x23, 0x42, 0x7e, 0xe0,
	0x8f, 0x9c, 0x47, 0x5a, 0x2d, 0x05, 0xdc, 0x84, 0xc2, 0x9b, 0xa8, 0x1f, 0x38, 0xbf, 0x9a, 0x21,
	0xfe, 0x36, 0xea, 0x07, 0xb3, 0x49, 0x24, 0x04, 0xee, 0x42, 0xe5, 0x8c, 0xc7, 0x82, 0xbf, 0x3f,
	0x26, 0x83, 0xdd, 0x4b, 0x0c, 0x40, 0x01, 0xa5, 0x5a, 0x86, 0xf3, 0x26, 0xec, 0x0b, 0x1e, 0x3b,
	0xbf, 0x4e, 0xc3, 0x51, 0x32, 0xde, 0x87, 0xab, 0xea, 0xdf, 0xb1, 0x2e, 0xe5, 0x37, 0x1a, 0xb0,
	0xa2, 0xd4, 0x47, 0xaa, 0x74, 0xdb, 0x80, 0xa9, 0xdf, 0x38, 0x1a, 0xa4, 0xd8, 0xc7, 0x1a, 0x6b,
	0x6b, 0x57, 0x71, 0x34, 0x50, 0xf8, 0xa7, 0x15, 0xb0, 0x92, 0x34, 0x16, 0xf6, 0x18, 0x56, 0x66,
	0x57, 0x0c, 0xda, 0x90, 0xff, 0x91, 0x9f, 0xeb, 0x45, 0x2b, 0xff, 0xe2, 0x3a, 0x14, 0xdf, 0x85,
	0xa2, 0x17, 0x0e, 0x69, 0xcf, 0x5a, 0x9e, 0x96, 0x58, 0x08, 0x6b, 0x0b, 0xf3, 0x8f, 0x08, 0x85,
	0x1f, 0xf9, 0xf9, 0x43, 0x6d, 0x4f, 0xff, 0xb5, 0xae, 0x41, 0x4b, 0x50, 0xe9, 0x1a, 0xf8, 0x00,
	0xac, 0xd3, 0x68, 0x18, 0x84, 0xf2, 0x45, 0x70, 0xf2, 0x77, 0x8d, 0xcd, 0xd5, 0xc6, 0x2a, 0x65,
	0xea, 0x59, 0xaa, 0xf5, 0xa6, 0x00, 0xb6, 0x05, 0xd7, 0xe6, 0x3a, 0x57, 0x46, 0x45, 0xfb, 0x4f,
	0xed, 0x6f, 0xcb, 0xd3, 0x12, 0x6b, 0xc3, 0xd5, 0x4f, 0x92, 0x2d, 0x81, 0x49, 0x34, 0x8e, 0x4f,
	0xb9, 0x8e, 0x49, 0x4b, 0x58, 0x83, 0x42, 0x38, 0x0c, 0x85, 0x5e, 0xcd, 0x4b, 0xda, 0xdd, 0x23,
	0x0c, 0xfb, 0x01, 0x8a, 0x47, 0x94, 0x45, 0x99, 0x9e, 0x6e, 0x18, 0xa4, 0xe9, 0xe9, 0x86, 0x81,
	0x7c, 0x9b, 0xd4, 0x22, 0x56, 0xd7, 0x53, 0x02, 0xfe, 0x12, 0x0a, 0x81, 0x2f, 0x7c, 0xba, 0x5a,
	0xa5, 0x71, 0x73, 0x81, 0xbd, 0x4d, 0x8f, 0x9d, 0x47, 0x20, 0xf6, 0x67, 0x28, 0xe8, 0xa9, 0xcf,
	0x46, 0x8e, 0x50, 0x90, 0x95, 0x26, 0x72, 0xcb, 0xa3, 0xff, 0xb8, 0x0a, 0x39, 0x11, 0x39, 0x05,
	0xd2, 0xe4, 0x44, 0x34, 0x09, 0xc0, 0xcc, 0x12, 0xc0, 0x5f, 0x0d, 0xa8, 0xa8, 0x57, 0x8f, 0x27,
	0xe3, 0xbe, 0xc0, 0xfb, 0x50, 0x54, 0x5d, 0xa3, 0x1f, 0xb9, 0x0a, 0x95, 0x46, 0xa5, 0x80, 0x76,
	0x86, 0x4a, 0xc6, 0x06, 0x14, 0x68, 0xb7, 0xa9, 0x14, 0x5a, 0x04, 0x92, 0x17, 0x91, 0x13, 0x21,
	0x0f, 0xf0, 0x81, 0x0e, 0xa2, 0xf0, 0x99, 0x95, 0x42, 0xa8, 0xa7, 0x65, 0xb9, 0x82, 0xa4, 0x7f,
	0xf6, 0x1a, 0x2c, 0x15, 0x89, 0x17, 0xbd, 0xc3, 0x5f, 0x80, 0xa9, 0x5e, 0x1e, 0x15, 0x8b, 0x4d,
	0x6e, 0x66, 0xa2, 0xf5, 0xd4, 0x31, 0x32, 0xc8, 0xc7, 0xd1, 0x3b, 0xfd, 0x31, 0xb0, 0x88, 0x92,
	0x87, 0xec, 0x77, 0x00, 0x6e, 0x10, 0x0a, 0x7d, 0xcd, 0x75, 0x30, 0x79, 0x1c, 0x47, 0xb1, 0xca,
	0xb8, 0x5c, 0x10, 0x24, 0xca, 0xed, 0x1b, 0x06, 0x2a, 0xe5, 0xf4, 0x38, 0x05, 0x33, 0xa1, 0xf5,
	0x60, 0x85, 0xd6, 0x8a, 0xdb, 0x57, 0xed, 0x75, 0xf1, 0xa7, 0xc9, 0x57, 0x93, 0x04, 0xe6, 0x16,
	0x12, 0x38, 0x49, 0xdf, 0x1d, 0x9d, 0xbe, 0xfc, 0x5c, 0xfa, 0x54, 0xf2, 0x58, 0x17, 0x4c, 0xf2,
	0xb4, 0xc4, 0xc5, 0x06, 0x98, 0x12, 0x96, 0xe8, 0x0b, 0xcf, 0x98, 0x2b, 0x3d, 0x7e, 0x0d, 0x65,
	0xe9, 0x28, 0x3c, 0xe5, 0x89, 0x93, 0x27, 0xcc, 0x27, 0x51, 0x4c, 0x0e, 0xd9, 0x06, 0x94, 0xc8,
	0x51, 0x73, 0xff, 0x62, 0x57, 0xec, 0x21, 0x58, 0xfa, 0xba, 0xcb, 0x20, 0xb2, 0xfd, 0xd2, 0x94,
	0xc9, 0x84, 0xb1, 0xb7, 0x50, 0x6a, 0x0e, 0x03, 0xfe, 0x7e, 0xa9, 0xc1, 0xc5, 0x9d, 0x7d, 0x03,
	0xcc, 0x37, 0x21, 0xef, 0x07, 0xba, 0xb5, 0x95, 0x80, 0xf7, 0xa0, 0x20, 0xce, 0x47, 0x9c, 0xda,
	0x68, 0x55, 0x97, 0x56, 0x07, 0xd4, 0x39, 0x1f, 0x71, 0x8f, 0x4e, 0xd9, 0x3f, 0x0c, 0x00, 0xf2,
	0x79, 0xd9, 0x37, 0xe3, 0x4f, 0xee, 0x76, 0xfa, 0x15, 0x6a, 0x7e, 0xf6, 0x2b, 0xd4, 0x83, 0x55,
	0x0a, 0xb0, 0xc3, 0xe3, 0x81, 0x7a, 0xf0, 0x6a, 0x50, 0x10, 0x3c, 0x1e, 0xe8, 0xd6, 0x5e, 0xba,
	0x84, 0x24, 0x46, 0x06, 0xa9, 0x5e, 0x4e, 0x19, 0xba, 0xa9, 0x5f, 0x55, 0xb6, 0x05, 0x56, 0x27,
	0x1c, 0xf0, 0x44, 0xf8, 0x83, 0x11, 0xde, 0x06, 0x4b, 0xa4, 0x82, 0xbe, 0xf7, 0x54, 0xc1, 0x4a,
	0x60, 0xba, 0x83, 0x91, 0x38, 0xaf, 0xfd, 0xdd, 0x00, 0x6b, 0xb2, 0x67, 0xf1, 0x0b, 0x58, 0x7b,
	0xd5, 0xfa, 0x7d, 0xeb, 0xf0, 0x75, 0xeb, 0xf8, 0xd9, 0x61, 0x6b, 0xbf, 0xd9, 0x69, 0x1e, 0xb6,
	0xec, 0x2b, 0x58, 0x84, 0x9c, 0xfb, 0xd2, 0x36, 0xb0, 0x04, 0xf9, 0x96, 0xfb, 0xd2, 0xce, 0x49,
	0xc5, 0x41, 0xc7, 0xce, 0x4b, 0xc5, 0x41, 0xc7, 0xb5, 0x0b, 0x52, 0xf1, 0xa2, 0x63, 0x9b, 0x52,
	0xf1, 0xa2, 0xe3, 0xda, 0x45, 0xac, 0x40, 0xe9, 0xa9, 0xdb, 0x79, 0xed, 0xba, 0x2d, 0xbb, 0x84,
	0x00, 0xc5, 0x66, 0xab, 0xdd, 0xdc, 0x77, 0xed, 0xb2, 0x3c, 0x38, 0x7c, 0xd5, 0x21, 0xc1, 0x92,
	0x07, 0xaf, 0x9b, 0x9d, 0xe7, 0xcd, 0x96, 0x0d, 0xf2, 0x40, 0xfe, 0x3f, 0x7c, 0xd5, 0xb1, 0x2b,
	0xb5, 0x5d, 0xa8, 0xcc, 0xa4, 0x17, 0x6d, 0x58, 0x49, 0xe3, 0xea, 0x7c, 0xff, 0x07, 0xd7, 0xbe,
	0x22, 0x2d, 0x8f, 0x5c, 0xaf, 0xe3, 0xfe, 0xd1, 0x36, 0xb0, 0x0c, 0x05, 0x77, 0xff, 0xc0, 0xb5,
	0x73, 0x8d, 0x7f, 0x9a, 0x60, 0xaa, 0x92, 0x7b, 0x60, 0x75, 0x62, 0xff, 0x8c, 0xc7, 0x89, 0xdf,
	0xc7, 0xf9, 0x0f, 0xfa, 0xaa, 0x7a, 0x5f, 0x26, 0x7b, 0x85, 0xb1, 0xbf, 0xfc, 0xfb, 0xbf, 0x7f,
	0xcb, 0xdd, 0x66, 0x37, 0xeb, 0x67, 0x0f, 0xeb, 0xd4, 0x1d, 0xf5, 0x0f, 0xf4, 0xf3, 0xb1, 0x4e,
	0xe5, 0xda, 0x33, 0x6a, 0x3b, 0x06, 0x1e, 0x82, 0x75, 0xc0, 0x85, 0xde, 0xfe, 0xab, 0xb3, 0x3d,
	0xd0, 0xdc, 0xaf, 0xce, 0x0e, 0x14, 0xbb, 0x4f, 0x7c, 0x1b, 0x78, 0x67, 0x91, 0x4f, 0x0d, 0x7c,
	0xfd, 0x43, 0x18, 0x7c, 0xc4, 0x26, 0x94, 0x0e, 0xb8, 0xfa, 0xa4, 0x9c, 0xa7, 0x9b, 0xce, 0x30,
	0xfb, 0x8a, 0xc8, 0xee, 0xe0, 0xcf, 0x16, 0xc9, 0xe4, 0x74, 0x2b, 0xaa, 0xdf, 0x52, 0x6c, 0x74,
	0xc5, 0x04, 0x41, 0x19, 0xcb, 0x02, 0x57, 0xe7, 0x88, 0xd9, 0x1a, 0xb1, 0x55, 0xd0, 0x9a, 0xb0,
	0xed, 0x18, 0xf8, 0x1d, 0xac, 0x1c, 0x70, 0x41, 0x0d, 0x29, 0xbf, 0xa9, 0x70, 0x65, 0x9a, 0xb0,
	0xe6, 0x7e, 0x55, 0x49, 0x7a, 0x86, 0xd9, 0x06, 0x11, 0xdc, 0xc2, 0x0b, 0x72, 0x15, 0x4a, 0xc8,
	0x8e, 0x81, 0x7f, 0x82, 0x72, 0x4a, 0x87, 0x9f, 0x18, 0x57, 0xaf, 0x4f, 0xa5, 0x49, 0xe7, 0xb3,
	0x3a, 0x31, 0x6e, 0xe1, 0xd7, 0x4b, 0x18, 0xeb, 0x1f, 0x68, 0x34, 0x3f, 0xd6, 0x3f, 0xd0, 0x30,
	0x7e, 0xdc, 0x31, 0xb0, 0x9b, 0x8e, 0xcf, 0x5c, 0x8d, 0xa7, 0x43, 0xbf, 0x50, 0xe3, 0x06, 0x79,
	0x79, 0xc0, 0xb2, 0x7a, 0x51, 0x35, 0x6f, 0x53, 0x66, 0xa6, 0x63, 0x35, 0x5f, 0x27, 0x25, 0x4f,
	0xce, 0x2f, 0x2b, 0xd6, 0x64, 0xfa, 0x1a, 0xff, 0x2a, 0xca, 0x57, 0x3e, 0x14, 0xf8, 0x3d, 0x58,
	0x4f, 0x82, 0x40, 0x77, 0xd4, 0xda, 0x34, 0xe9, 0x9a, 0xbf, 0x7a, 0x4d, 0x77, 0x41, 0xfa, 0x4c,
	0xb1, 0x4d, 0xa2, 0x67, 0xcc, 0x59, 0xd6, 0x58, 0x7b, 0xe9, 0x8b, 0xd2, 0x86, 0xd2, 0x93, 0x20,
	0xa0, 0xde, 0xca, 0x42, 0x7c, 0x8f, 0x88, 0xbf, 0x64, 0xeb, 0x17, 0x37, 0xd9, 0x9e, 0x7a, 0xc4,
	0x9b, 0xb0, 0xda, 0x16, 0x31, 0xf7, 0x07, 0x9a, 0x27, 0xc9, 0xc4, 0xad, 0x5b, 0x8e, 0x4d, 0x5b,
	0x6e, 0xd3, 0xc0, 0x6f, 0xa1, 0xfc, 0x24, 0x08, 0xd4, 0xab, 0x36, 0x9f, 0xd4, 0x05, 0x86, 0x5b,
	0xc4, 0x70, 0x9d, 0xad, 0x2d, 0x44, 0x87, 0x2f, 0xa1, 0xf2, 0x24, 0x08, 0xda, 0xe3, 0x13, 0x45,
	0x05, 0xd3, 0x78, 0x16, 0x69, 0xf4, 0x58, 0xb2, 0xea, 0xe2, 0x25, 0x93, 0xf1, 0x09, 0xfd, 0xdb,
	0x33, 0x6a, 0xd8, 0x84, 0xca, 0x3e, 0xef, 0x73, 0xc1, 0xff, 0xbf, 0xe8, 0x6a, 0x17, 0x44, 0x77,
	0x04, 0x2b, 0x8a, 0x6a, 0xc9, 0xd6, 0x58, 0x16, 0x62, 0xed, 0x33, 0x9b, 0xc3, 0x03, 0x50, 0xbc,
	0x17, 0x2e, 0x8f, 0x05, 0x56, 0xdd, 0x95, 0xb5, 0x4b, 0x57, 0xc8, 0x2b, 0xaa, 0xc8, 0x45, 0x53,
	0xbb, 0xc0, 0x57, 0x23, 0xbe, 0x7b, 0x6c, 0xe3, 0x33, 0xb3, 0x24, 0xb3, 0xf9, 0x43, 0x9a, 0xcd,
	0x4c, 0xcc, 0x7a, 0x17, 0xd4, 0xb2, 0x4e, 0xe9, 0x49, 0x91, 0x1e, 0xc8, 0x47, 0xff, 0x0b, 0x00,
	0x00, 0xff, 0xff, 0xd8, 0x3d, 0xb8, 0x92, 0x72, 0x12, 0x00, 0x00,
}
