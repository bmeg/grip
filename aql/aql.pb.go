// Code generated by protoc-gen-go. DO NOT EDIT.
// source: aql.proto

/*
Package aql is a generated protocol buffer package.

It is generated from these files:
	aql.proto

It has these top-level messages:
	Graph
	GraphQuery
	QuerySet
	MatchQuerySet
	GraphStatement
	AggregationsRequest
	Aggregations
	Aggregate
	TermAggregation
	PercentileAggregation
	HistogramAggregation
	NamedAggregationResult
	AggregationResult
	AggregationResultBucket
	WhereExpressionList
	WhereExpression
	WhereCondition
	SelectStatement
	Selection
	Selections
	Vertex
	Edge
	QueryResult
	EditResult
	GraphElement
	GraphID
	ElementID
	IndexID
	Timestamp
	Empty
*/
package aql

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/struct"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Condition int32

const (
	Condition_UNKNOWN_CONDITION Condition = 0
	Condition_EQ                Condition = 1
	Condition_NEQ               Condition = 2
	Condition_GT                Condition = 3
	Condition_GTE               Condition = 4
	Condition_LT                Condition = 5
	Condition_LTE               Condition = 6
	Condition_IN                Condition = 7
	Condition_CONTAINS          Condition = 8
)

var Condition_name = map[int32]string{
	0: "UNKNOWN_CONDITION",
	1: "EQ",
	2: "NEQ",
	3: "GT",
	4: "GTE",
	5: "LT",
	6: "LTE",
	7: "IN",
	8: "CONTAINS",
}
var Condition_value = map[string]int32{
	"UNKNOWN_CONDITION": 0,
	"EQ":                1,
	"NEQ":               2,
	"GT":                3,
	"GTE":               4,
	"LT":                5,
	"LTE":               6,
	"IN":                7,
	"CONTAINS":          8,
}

func (x Condition) String() string {
	return proto.EnumName(Condition_name, int32(x))
}
func (Condition) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Graph struct {
	Graph    string    `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Vertices []*Vertex `protobuf:"bytes,2,rep,name=vertices" json:"vertices,omitempty"`
	Edges    []*Edge   `protobuf:"bytes,3,rep,name=edges" json:"edges,omitempty"`
}

func (m *Graph) Reset()                    { *m = Graph{} }
func (m *Graph) String() string            { return proto.CompactTextString(m) }
func (*Graph) ProtoMessage()               {}
func (*Graph) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Graph) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *Graph) GetVertices() []*Vertex {
	if m != nil {
		return m.Vertices
	}
	return nil
}

func (m *Graph) GetEdges() []*Edge {
	if m != nil {
		return m.Edges
	}
	return nil
}

type GraphQuery struct {
	Graph string            `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Query []*GraphStatement `protobuf:"bytes,2,rep,name=query" json:"query,omitempty"`
}

func (m *GraphQuery) Reset()                    { *m = GraphQuery{} }
func (m *GraphQuery) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery) ProtoMessage()               {}
func (*GraphQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GraphQuery) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *GraphQuery) GetQuery() []*GraphStatement {
	if m != nil {
		return m.Query
	}
	return nil
}

type QuerySet struct {
	Query []*GraphStatement `protobuf:"bytes,1,rep,name=query" json:"query,omitempty"`
}

func (m *QuerySet) Reset()                    { *m = QuerySet{} }
func (m *QuerySet) String() string            { return proto.CompactTextString(m) }
func (*QuerySet) ProtoMessage()               {}
func (*QuerySet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *QuerySet) GetQuery() []*GraphStatement {
	if m != nil {
		return m.Query
	}
	return nil
}

type MatchQuerySet struct {
	Queries []*QuerySet `protobuf:"bytes,1,rep,name=queries" json:"queries,omitempty"`
}

func (m *MatchQuerySet) Reset()                    { *m = MatchQuerySet{} }
func (m *MatchQuerySet) String() string            { return proto.CompactTextString(m) }
func (*MatchQuerySet) ProtoMessage()               {}
func (*MatchQuerySet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MatchQuerySet) GetQueries() []*QuerySet {
	if m != nil {
		return m.Queries
	}
	return nil
}

type GraphStatement struct {
	// Types that are valid to be assigned to Statement:
	//	*GraphStatement_V
	//	*GraphStatement_E
	//	*GraphStatement_In
	//	*GraphStatement_Out
	//	*GraphStatement_InEdge
	//	*GraphStatement_OutEdge
	//	*GraphStatement_Both
	//	*GraphStatement_BothEdge
	//	*GraphStatement_Mark
	//	*GraphStatement_Select
	//	*GraphStatement_Limit
	//	*GraphStatement_Offset
	//	*GraphStatement_Fields
	//	*GraphStatement_Distinct
	//	*GraphStatement_Match
	//	*GraphStatement_Where
	//	*GraphStatement_Count
	//	*GraphStatement_Aggregate
	//	*GraphStatement_Render
	Statement isGraphStatement_Statement `protobuf_oneof:"statement"`
}

func (m *GraphStatement) Reset()                    { *m = GraphStatement{} }
func (m *GraphStatement) String() string            { return proto.CompactTextString(m) }
func (*GraphStatement) ProtoMessage()               {}
func (*GraphStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isGraphStatement_Statement interface{ isGraphStatement_Statement() }

type GraphStatement_V struct {
	V *google_protobuf1.ListValue `protobuf:"bytes,1,opt,name=v,oneof"`
}
type GraphStatement_E struct {
	E *google_protobuf1.ListValue `protobuf:"bytes,2,opt,name=e,oneof"`
}
type GraphStatement_In struct {
	In *google_protobuf1.ListValue `protobuf:"bytes,10,opt,name=in,oneof"`
}
type GraphStatement_Out struct {
	Out *google_protobuf1.ListValue `protobuf:"bytes,11,opt,name=out,oneof"`
}
type GraphStatement_InEdge struct {
	InEdge *google_protobuf1.ListValue `protobuf:"bytes,12,opt,name=in_edge,json=inEdge,oneof"`
}
type GraphStatement_OutEdge struct {
	OutEdge *google_protobuf1.ListValue `protobuf:"bytes,13,opt,name=out_edge,json=outEdge,oneof"`
}
type GraphStatement_Both struct {
	Both *google_protobuf1.ListValue `protobuf:"bytes,14,opt,name=both,oneof"`
}
type GraphStatement_BothEdge struct {
	BothEdge *google_protobuf1.ListValue `protobuf:"bytes,15,opt,name=both_edge,json=bothEdge,oneof"`
}
type GraphStatement_Mark struct {
	Mark string `protobuf:"bytes,20,opt,name=mark,oneof"`
}
type GraphStatement_Select struct {
	Select *SelectStatement `protobuf:"bytes,21,opt,name=select,oneof"`
}
type GraphStatement_Limit struct {
	Limit uint32 `protobuf:"varint,24,opt,name=limit,oneof"`
}
type GraphStatement_Offset struct {
	Offset uint32 `protobuf:"varint,25,opt,name=offset,oneof"`
}
type GraphStatement_Fields struct {
	Fields *google_protobuf1.ListValue `protobuf:"bytes,26,opt,name=fields,oneof"`
}
type GraphStatement_Distinct struct {
	Distinct *google_protobuf1.ListValue `protobuf:"bytes,27,opt,name=distinct,oneof"`
}
type GraphStatement_Match struct {
	Match *MatchQuerySet `protobuf:"bytes,28,opt,name=match,oneof"`
}
type GraphStatement_Where struct {
	Where *WhereExpression `protobuf:"bytes,29,opt,name=where,oneof"`
}
type GraphStatement_Count struct {
	Count string `protobuf:"bytes,30,opt,name=count,oneof"`
}
type GraphStatement_Aggregate struct {
	Aggregate *Aggregations `protobuf:"bytes,31,opt,name=aggregate,oneof"`
}
type GraphStatement_Render struct {
	Render *google_protobuf1.Value `protobuf:"bytes,32,opt,name=render,oneof"`
}

func (*GraphStatement_V) isGraphStatement_Statement()         {}
func (*GraphStatement_E) isGraphStatement_Statement()         {}
func (*GraphStatement_In) isGraphStatement_Statement()        {}
func (*GraphStatement_Out) isGraphStatement_Statement()       {}
func (*GraphStatement_InEdge) isGraphStatement_Statement()    {}
func (*GraphStatement_OutEdge) isGraphStatement_Statement()   {}
func (*GraphStatement_Both) isGraphStatement_Statement()      {}
func (*GraphStatement_BothEdge) isGraphStatement_Statement()  {}
func (*GraphStatement_Mark) isGraphStatement_Statement()      {}
func (*GraphStatement_Select) isGraphStatement_Statement()    {}
func (*GraphStatement_Limit) isGraphStatement_Statement()     {}
func (*GraphStatement_Offset) isGraphStatement_Statement()    {}
func (*GraphStatement_Fields) isGraphStatement_Statement()    {}
func (*GraphStatement_Distinct) isGraphStatement_Statement()  {}
func (*GraphStatement_Match) isGraphStatement_Statement()     {}
func (*GraphStatement_Where) isGraphStatement_Statement()     {}
func (*GraphStatement_Count) isGraphStatement_Statement()     {}
func (*GraphStatement_Aggregate) isGraphStatement_Statement() {}
func (*GraphStatement_Render) isGraphStatement_Statement()    {}

func (m *GraphStatement) GetStatement() isGraphStatement_Statement {
	if m != nil {
		return m.Statement
	}
	return nil
}

func (m *GraphStatement) GetV() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_V); ok {
		return x.V
	}
	return nil
}

func (m *GraphStatement) GetE() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_E); ok {
		return x.E
	}
	return nil
}

func (m *GraphStatement) GetIn() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_In); ok {
		return x.In
	}
	return nil
}

func (m *GraphStatement) GetOut() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Out); ok {
		return x.Out
	}
	return nil
}

func (m *GraphStatement) GetInEdge() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_InEdge); ok {
		return x.InEdge
	}
	return nil
}

func (m *GraphStatement) GetOutEdge() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_OutEdge); ok {
		return x.OutEdge
	}
	return nil
}

func (m *GraphStatement) GetBoth() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Both); ok {
		return x.Both
	}
	return nil
}

func (m *GraphStatement) GetBothEdge() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_BothEdge); ok {
		return x.BothEdge
	}
	return nil
}

func (m *GraphStatement) GetMark() string {
	if x, ok := m.GetStatement().(*GraphStatement_Mark); ok {
		return x.Mark
	}
	return ""
}

func (m *GraphStatement) GetSelect() *SelectStatement {
	if x, ok := m.GetStatement().(*GraphStatement_Select); ok {
		return x.Select
	}
	return nil
}

func (m *GraphStatement) GetLimit() uint32 {
	if x, ok := m.GetStatement().(*GraphStatement_Limit); ok {
		return x.Limit
	}
	return 0
}

func (m *GraphStatement) GetOffset() uint32 {
	if x, ok := m.GetStatement().(*GraphStatement_Offset); ok {
		return x.Offset
	}
	return 0
}

func (m *GraphStatement) GetFields() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Fields); ok {
		return x.Fields
	}
	return nil
}

func (m *GraphStatement) GetDistinct() *google_protobuf1.ListValue {
	if x, ok := m.GetStatement().(*GraphStatement_Distinct); ok {
		return x.Distinct
	}
	return nil
}

func (m *GraphStatement) GetMatch() *MatchQuerySet {
	if x, ok := m.GetStatement().(*GraphStatement_Match); ok {
		return x.Match
	}
	return nil
}

func (m *GraphStatement) GetWhere() *WhereExpression {
	if x, ok := m.GetStatement().(*GraphStatement_Where); ok {
		return x.Where
	}
	return nil
}

func (m *GraphStatement) GetCount() string {
	if x, ok := m.GetStatement().(*GraphStatement_Count); ok {
		return x.Count
	}
	return ""
}

func (m *GraphStatement) GetAggregate() *Aggregations {
	if x, ok := m.GetStatement().(*GraphStatement_Aggregate); ok {
		return x.Aggregate
	}
	return nil
}

func (m *GraphStatement) GetRender() *google_protobuf1.Value {
	if x, ok := m.GetStatement().(*GraphStatement_Render); ok {
		return x.Render
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GraphStatement) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GraphStatement_OneofMarshaler, _GraphStatement_OneofUnmarshaler, _GraphStatement_OneofSizer, []interface{}{
		(*GraphStatement_V)(nil),
		(*GraphStatement_E)(nil),
		(*GraphStatement_In)(nil),
		(*GraphStatement_Out)(nil),
		(*GraphStatement_InEdge)(nil),
		(*GraphStatement_OutEdge)(nil),
		(*GraphStatement_Both)(nil),
		(*GraphStatement_BothEdge)(nil),
		(*GraphStatement_Mark)(nil),
		(*GraphStatement_Select)(nil),
		(*GraphStatement_Limit)(nil),
		(*GraphStatement_Offset)(nil),
		(*GraphStatement_Fields)(nil),
		(*GraphStatement_Distinct)(nil),
		(*GraphStatement_Match)(nil),
		(*GraphStatement_Where)(nil),
		(*GraphStatement_Count)(nil),
		(*GraphStatement_Aggregate)(nil),
		(*GraphStatement_Render)(nil),
	}
}

func _GraphStatement_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GraphStatement)
	// statement
	switch x := m.Statement.(type) {
	case *GraphStatement_V:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V); err != nil {
			return err
		}
	case *GraphStatement_E:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.E); err != nil {
			return err
		}
	case *GraphStatement_In:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.In); err != nil {
			return err
		}
	case *GraphStatement_Out:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Out); err != nil {
			return err
		}
	case *GraphStatement_InEdge:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InEdge); err != nil {
			return err
		}
	case *GraphStatement_OutEdge:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OutEdge); err != nil {
			return err
		}
	case *GraphStatement_Both:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Both); err != nil {
			return err
		}
	case *GraphStatement_BothEdge:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BothEdge); err != nil {
			return err
		}
	case *GraphStatement_Mark:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Mark)
	case *GraphStatement_Select:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Select); err != nil {
			return err
		}
	case *GraphStatement_Limit:
		b.EncodeVarint(24<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Limit))
	case *GraphStatement_Offset:
		b.EncodeVarint(25<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Offset))
	case *GraphStatement_Fields:
		b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fields); err != nil {
			return err
		}
	case *GraphStatement_Distinct:
		b.EncodeVarint(27<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Distinct); err != nil {
			return err
		}
	case *GraphStatement_Match:
		b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Match); err != nil {
			return err
		}
	case *GraphStatement_Where:
		b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Where); err != nil {
			return err
		}
	case *GraphStatement_Count:
		b.EncodeVarint(30<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Count)
	case *GraphStatement_Aggregate:
		b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aggregate); err != nil {
			return err
		}
	case *GraphStatement_Render:
		b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Render); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GraphStatement.Statement has unexpected type %T", x)
	}
	return nil
}

func _GraphStatement_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GraphStatement)
	switch tag {
	case 1: // statement.v
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_V{msg}
		return true, err
	case 2: // statement.e
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_E{msg}
		return true, err
	case 10: // statement.in
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_In{msg}
		return true, err
	case 11: // statement.out
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Out{msg}
		return true, err
	case 12: // statement.in_edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_InEdge{msg}
		return true, err
	case 13: // statement.out_edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_OutEdge{msg}
		return true, err
	case 14: // statement.both
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Both{msg}
		return true, err
	case 15: // statement.both_edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_BothEdge{msg}
		return true, err
	case 20: // statement.mark
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_Mark{x}
		return true, err
	case 21: // statement.select
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SelectStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Select{msg}
		return true, err
	case 24: // statement.limit
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Statement = &GraphStatement_Limit{uint32(x)}
		return true, err
	case 25: // statement.offset
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Statement = &GraphStatement_Offset{uint32(x)}
		return true, err
	case 26: // statement.fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Fields{msg}
		return true, err
	case 27: // statement.distinct
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.ListValue)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Distinct{msg}
		return true, err
	case 28: // statement.match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchQuerySet)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Match{msg}
		return true, err
	case 29: // statement.where
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WhereExpression)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Where{msg}
		return true, err
	case 30: // statement.count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Statement = &GraphStatement_Count{x}
		return true, err
	case 31: // statement.aggregate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregations)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Aggregate{msg}
		return true, err
	case 32: // statement.render
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Value)
		err := b.DecodeMessage(msg)
		m.Statement = &GraphStatement_Render{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GraphStatement_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GraphStatement)
	// statement
	switch x := m.Statement.(type) {
	case *GraphStatement_V:
		s := proto.Size(x.V)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_E:
		s := proto.Size(x.E)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_In:
		s := proto.Size(x.In)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Out:
		s := proto.Size(x.Out)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_InEdge:
		s := proto.Size(x.InEdge)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_OutEdge:
		s := proto.Size(x.OutEdge)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Both:
		s := proto.Size(x.Both)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_BothEdge:
		s := proto.Size(x.BothEdge)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Mark:
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Mark)))
		n += len(x.Mark)
	case *GraphStatement_Select:
		s := proto.Size(x.Select)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Limit:
		n += proto.SizeVarint(24<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Limit))
	case *GraphStatement_Offset:
		n += proto.SizeVarint(25<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Offset))
	case *GraphStatement_Fields:
		s := proto.Size(x.Fields)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Distinct:
		s := proto.Size(x.Distinct)
		n += proto.SizeVarint(27<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Match:
		s := proto.Size(x.Match)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Where:
		s := proto.Size(x.Where)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Count:
		n += proto.SizeVarint(30<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Count)))
		n += len(x.Count)
	case *GraphStatement_Aggregate:
		s := proto.Size(x.Aggregate)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GraphStatement_Render:
		s := proto.Size(x.Render)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AggregationsRequest struct {
	Graph        string       `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Aggregations []*Aggregate `protobuf:"bytes,2,rep,name=aggregations" json:"aggregations,omitempty"`
}

func (m *AggregationsRequest) Reset()                    { *m = AggregationsRequest{} }
func (m *AggregationsRequest) String() string            { return proto.CompactTextString(m) }
func (*AggregationsRequest) ProtoMessage()               {}
func (*AggregationsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AggregationsRequest) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *AggregationsRequest) GetAggregations() []*Aggregate {
	if m != nil {
		return m.Aggregations
	}
	return nil
}

type Aggregations struct {
	Aggregations []*Aggregate `protobuf:"bytes,1,rep,name=aggregations" json:"aggregations,omitempty"`
}

func (m *Aggregations) Reset()                    { *m = Aggregations{} }
func (m *Aggregations) String() string            { return proto.CompactTextString(m) }
func (*Aggregations) ProtoMessage()               {}
func (*Aggregations) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Aggregations) GetAggregations() []*Aggregate {
	if m != nil {
		return m.Aggregations
	}
	return nil
}

type Aggregate struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Types that are valid to be assigned to Aggregation:
	//	*Aggregate_Term
	//	*Aggregate_Percentile
	//	*Aggregate_Histogram
	Aggregation isAggregate_Aggregation `protobuf_oneof:"aggregation"`
}

func (m *Aggregate) Reset()                    { *m = Aggregate{} }
func (m *Aggregate) String() string            { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()               {}
func (*Aggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isAggregate_Aggregation interface{ isAggregate_Aggregation() }

type Aggregate_Term struct {
	Term *TermAggregation `protobuf:"bytes,2,opt,name=term,oneof"`
}
type Aggregate_Percentile struct {
	Percentile *PercentileAggregation `protobuf:"bytes,3,opt,name=percentile,oneof"`
}
type Aggregate_Histogram struct {
	Histogram *HistogramAggregation `protobuf:"bytes,4,opt,name=histogram,oneof"`
}

func (*Aggregate_Term) isAggregate_Aggregation()       {}
func (*Aggregate_Percentile) isAggregate_Aggregation() {}
func (*Aggregate_Histogram) isAggregate_Aggregation()  {}

func (m *Aggregate) GetAggregation() isAggregate_Aggregation {
	if m != nil {
		return m.Aggregation
	}
	return nil
}

func (m *Aggregate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Aggregate) GetTerm() *TermAggregation {
	if x, ok := m.GetAggregation().(*Aggregate_Term); ok {
		return x.Term
	}
	return nil
}

func (m *Aggregate) GetPercentile() *PercentileAggregation {
	if x, ok := m.GetAggregation().(*Aggregate_Percentile); ok {
		return x.Percentile
	}
	return nil
}

func (m *Aggregate) GetHistogram() *HistogramAggregation {
	if x, ok := m.GetAggregation().(*Aggregate_Histogram); ok {
		return x.Histogram
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Aggregate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Aggregate_OneofMarshaler, _Aggregate_OneofUnmarshaler, _Aggregate_OneofSizer, []interface{}{
		(*Aggregate_Term)(nil),
		(*Aggregate_Percentile)(nil),
		(*Aggregate_Histogram)(nil),
	}
}

func _Aggregate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Aggregate)
	// aggregation
	switch x := m.Aggregation.(type) {
	case *Aggregate_Term:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Term); err != nil {
			return err
		}
	case *Aggregate_Percentile:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Percentile); err != nil {
			return err
		}
	case *Aggregate_Histogram:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Histogram); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Aggregate.Aggregation has unexpected type %T", x)
	}
	return nil
}

func _Aggregate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Aggregate)
	switch tag {
	case 2: // aggregation.term
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TermAggregation)
		err := b.DecodeMessage(msg)
		m.Aggregation = &Aggregate_Term{msg}
		return true, err
	case 3: // aggregation.percentile
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PercentileAggregation)
		err := b.DecodeMessage(msg)
		m.Aggregation = &Aggregate_Percentile{msg}
		return true, err
	case 4: // aggregation.histogram
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HistogramAggregation)
		err := b.DecodeMessage(msg)
		m.Aggregation = &Aggregate_Histogram{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Aggregate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Aggregate)
	// aggregation
	switch x := m.Aggregation.(type) {
	case *Aggregate_Term:
		s := proto.Size(x.Term)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Aggregate_Percentile:
		s := proto.Size(x.Percentile)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Aggregate_Histogram:
		s := proto.Size(x.Histogram)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TermAggregation struct {
	Label string `protobuf:"bytes,1,opt,name=label" json:"label,omitempty"`
	Field string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	Size  uint32 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
}

func (m *TermAggregation) Reset()                    { *m = TermAggregation{} }
func (m *TermAggregation) String() string            { return proto.CompactTextString(m) }
func (*TermAggregation) ProtoMessage()               {}
func (*TermAggregation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *TermAggregation) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *TermAggregation) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *TermAggregation) GetSize() uint32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type PercentileAggregation struct {
	Label    string    `protobuf:"bytes,1,opt,name=label" json:"label,omitempty"`
	Field    string    `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	Percents []float64 `protobuf:"fixed64,3,rep,packed,name=percents" json:"percents,omitempty"`
}

func (m *PercentileAggregation) Reset()                    { *m = PercentileAggregation{} }
func (m *PercentileAggregation) String() string            { return proto.CompactTextString(m) }
func (*PercentileAggregation) ProtoMessage()               {}
func (*PercentileAggregation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PercentileAggregation) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *PercentileAggregation) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *PercentileAggregation) GetPercents() []float64 {
	if m != nil {
		return m.Percents
	}
	return nil
}

type HistogramAggregation struct {
	Label    string `protobuf:"bytes,1,opt,name=label" json:"label,omitempty"`
	Field    string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	Interval uint32 `protobuf:"varint,3,opt,name=interval" json:"interval,omitempty"`
}

func (m *HistogramAggregation) Reset()                    { *m = HistogramAggregation{} }
func (m *HistogramAggregation) String() string            { return proto.CompactTextString(m) }
func (*HistogramAggregation) ProtoMessage()               {}
func (*HistogramAggregation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *HistogramAggregation) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *HistogramAggregation) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *HistogramAggregation) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

type NamedAggregationResult struct {
	Aggregations map[string]*AggregationResult `protobuf:"bytes,3,rep,name=aggregations" json:"aggregations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NamedAggregationResult) Reset()                    { *m = NamedAggregationResult{} }
func (m *NamedAggregationResult) String() string            { return proto.CompactTextString(m) }
func (*NamedAggregationResult) ProtoMessage()               {}
func (*NamedAggregationResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *NamedAggregationResult) GetAggregations() map[string]*AggregationResult {
	if m != nil {
		return m.Aggregations
	}
	return nil
}

type AggregationResult struct {
	Buckets []*AggregationResultBucket `protobuf:"bytes,2,rep,name=buckets" json:"buckets,omitempty"`
}

func (m *AggregationResult) Reset()                    { *m = AggregationResult{} }
func (m *AggregationResult) String() string            { return proto.CompactTextString(m) }
func (*AggregationResult) ProtoMessage()               {}
func (*AggregationResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *AggregationResult) GetBuckets() []*AggregationResultBucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

type AggregationResultBucket struct {
	Key   *google_protobuf1.Value `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value float64                 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *AggregationResultBucket) Reset()                    { *m = AggregationResultBucket{} }
func (m *AggregationResultBucket) String() string            { return proto.CompactTextString(m) }
func (*AggregationResultBucket) ProtoMessage()               {}
func (*AggregationResultBucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *AggregationResultBucket) GetKey() *google_protobuf1.Value {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AggregationResultBucket) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type WhereExpressionList struct {
	Expressions []*WhereExpression `protobuf:"bytes,1,rep,name=expressions" json:"expressions,omitempty"`
}

func (m *WhereExpressionList) Reset()                    { *m = WhereExpressionList{} }
func (m *WhereExpressionList) String() string            { return proto.CompactTextString(m) }
func (*WhereExpressionList) ProtoMessage()               {}
func (*WhereExpressionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *WhereExpressionList) GetExpressions() []*WhereExpression {
	if m != nil {
		return m.Expressions
	}
	return nil
}

type WhereExpression struct {
	// Types that are valid to be assigned to Expression:
	//	*WhereExpression_And
	//	*WhereExpression_Or
	//	*WhereExpression_Not
	//	*WhereExpression_Condition
	Expression isWhereExpression_Expression `protobuf_oneof:"expression"`
}

func (m *WhereExpression) Reset()                    { *m = WhereExpression{} }
func (m *WhereExpression) String() string            { return proto.CompactTextString(m) }
func (*WhereExpression) ProtoMessage()               {}
func (*WhereExpression) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isWhereExpression_Expression interface{ isWhereExpression_Expression() }

type WhereExpression_And struct {
	And *WhereExpressionList `protobuf:"bytes,1,opt,name=and,oneof"`
}
type WhereExpression_Or struct {
	Or *WhereExpressionList `protobuf:"bytes,2,opt,name=or,oneof"`
}
type WhereExpression_Not struct {
	Not *WhereExpression `protobuf:"bytes,3,opt,name=not,oneof"`
}
type WhereExpression_Condition struct {
	Condition *WhereCondition `protobuf:"bytes,4,opt,name=condition,oneof"`
}

func (*WhereExpression_And) isWhereExpression_Expression()       {}
func (*WhereExpression_Or) isWhereExpression_Expression()        {}
func (*WhereExpression_Not) isWhereExpression_Expression()       {}
func (*WhereExpression_Condition) isWhereExpression_Expression() {}

func (m *WhereExpression) GetExpression() isWhereExpression_Expression {
	if m != nil {
		return m.Expression
	}
	return nil
}

func (m *WhereExpression) GetAnd() *WhereExpressionList {
	if x, ok := m.GetExpression().(*WhereExpression_And); ok {
		return x.And
	}
	return nil
}

func (m *WhereExpression) GetOr() *WhereExpressionList {
	if x, ok := m.GetExpression().(*WhereExpression_Or); ok {
		return x.Or
	}
	return nil
}

func (m *WhereExpression) GetNot() *WhereExpression {
	if x, ok := m.GetExpression().(*WhereExpression_Not); ok {
		return x.Not
	}
	return nil
}

func (m *WhereExpression) GetCondition() *WhereCondition {
	if x, ok := m.GetExpression().(*WhereExpression_Condition); ok {
		return x.Condition
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WhereExpression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WhereExpression_OneofMarshaler, _WhereExpression_OneofUnmarshaler, _WhereExpression_OneofSizer, []interface{}{
		(*WhereExpression_And)(nil),
		(*WhereExpression_Or)(nil),
		(*WhereExpression_Not)(nil),
		(*WhereExpression_Condition)(nil),
	}
}

func _WhereExpression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WhereExpression)
	// expression
	switch x := m.Expression.(type) {
	case *WhereExpression_And:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.And); err != nil {
			return err
		}
	case *WhereExpression_Or:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Or); err != nil {
			return err
		}
	case *WhereExpression_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *WhereExpression_Condition:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Condition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WhereExpression.Expression has unexpected type %T", x)
	}
	return nil
}

func _WhereExpression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WhereExpression)
	switch tag {
	case 1: // expression.and
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WhereExpressionList)
		err := b.DecodeMessage(msg)
		m.Expression = &WhereExpression_And{msg}
		return true, err
	case 2: // expression.or
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WhereExpressionList)
		err := b.DecodeMessage(msg)
		m.Expression = &WhereExpression_Or{msg}
		return true, err
	case 3: // expression.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WhereExpression)
		err := b.DecodeMessage(msg)
		m.Expression = &WhereExpression_Not{msg}
		return true, err
	case 4: // expression.condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WhereCondition)
		err := b.DecodeMessage(msg)
		m.Expression = &WhereExpression_Condition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WhereExpression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WhereExpression)
	// expression
	switch x := m.Expression.(type) {
	case *WhereExpression_And:
		s := proto.Size(x.And)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WhereExpression_Or:
		s := proto.Size(x.Or)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WhereExpression_Not:
		s := proto.Size(x.Not)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WhereExpression_Condition:
		s := proto.Size(x.Condition)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WhereCondition struct {
	Key       string                  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value     *google_protobuf1.Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Condition Condition               `protobuf:"varint,3,opt,name=condition,enum=aql.Condition" json:"condition,omitempty"`
}

func (m *WhereCondition) Reset()                    { *m = WhereCondition{} }
func (m *WhereCondition) String() string            { return proto.CompactTextString(m) }
func (*WhereCondition) ProtoMessage()               {}
func (*WhereCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *WhereCondition) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *WhereCondition) GetValue() *google_protobuf1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WhereCondition) GetCondition() Condition {
	if m != nil {
		return m.Condition
	}
	return Condition_UNKNOWN_CONDITION
}

type SelectStatement struct {
	Marks []string `protobuf:"bytes,1,rep,name=marks" json:"marks,omitempty"`
}

func (m *SelectStatement) Reset()                    { *m = SelectStatement{} }
func (m *SelectStatement) String() string            { return proto.CompactTextString(m) }
func (*SelectStatement) ProtoMessage()               {}
func (*SelectStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SelectStatement) GetMarks() []string {
	if m != nil {
		return m.Marks
	}
	return nil
}

type Selection struct {
	// Types that are valid to be assigned to Result:
	//	*Selection_Vertex
	//	*Selection_Edge
	Result isSelection_Result `protobuf_oneof:"result"`
}

func (m *Selection) Reset()                    { *m = Selection{} }
func (m *Selection) String() string            { return proto.CompactTextString(m) }
func (*Selection) ProtoMessage()               {}
func (*Selection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

type isSelection_Result interface{ isSelection_Result() }

type Selection_Vertex struct {
	Vertex *Vertex `protobuf:"bytes,1,opt,name=vertex,oneof"`
}
type Selection_Edge struct {
	Edge *Edge `protobuf:"bytes,2,opt,name=edge,oneof"`
}

func (*Selection_Vertex) isSelection_Result() {}
func (*Selection_Edge) isSelection_Result()   {}

func (m *Selection) GetResult() isSelection_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Selection) GetVertex() *Vertex {
	if x, ok := m.GetResult().(*Selection_Vertex); ok {
		return x.Vertex
	}
	return nil
}

func (m *Selection) GetEdge() *Edge {
	if x, ok := m.GetResult().(*Selection_Edge); ok {
		return x.Edge
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Selection) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Selection_OneofMarshaler, _Selection_OneofUnmarshaler, _Selection_OneofSizer, []interface{}{
		(*Selection_Vertex)(nil),
		(*Selection_Edge)(nil),
	}
}

func _Selection_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Selection)
	// result
	switch x := m.Result.(type) {
	case *Selection_Vertex:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vertex); err != nil {
			return err
		}
	case *Selection_Edge:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Edge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Selection.Result has unexpected type %T", x)
	}
	return nil
}

func _Selection_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Selection)
	switch tag {
	case 1: // result.vertex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Vertex)
		err := b.DecodeMessage(msg)
		m.Result = &Selection_Vertex{msg}
		return true, err
	case 2: // result.edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Edge)
		err := b.DecodeMessage(msg)
		m.Result = &Selection_Edge{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Selection_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Selection)
	// result
	switch x := m.Result.(type) {
	case *Selection_Vertex:
		s := proto.Size(x.Vertex)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selection_Edge:
		s := proto.Size(x.Edge)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Selections struct {
	Selections map[string]*Selection `protobuf:"bytes,1,rep,name=selections" json:"selections,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Selections) Reset()                    { *m = Selections{} }
func (m *Selections) String() string            { return proto.CompactTextString(m) }
func (*Selections) ProtoMessage()               {}
func (*Selections) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Selections) GetSelections() map[string]*Selection {
	if m != nil {
		return m.Selections
	}
	return nil
}

type Vertex struct {
	Gid   string                   `protobuf:"bytes,1,opt,name=gid" json:"gid,omitempty"`
	Label string                   `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Data  *google_protobuf1.Struct `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Vertex) Reset()                    { *m = Vertex{} }
func (m *Vertex) String() string            { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()               {}
func (*Vertex) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Vertex) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *Vertex) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Vertex) GetData() *google_protobuf1.Struct {
	if m != nil {
		return m.Data
	}
	return nil
}

type Edge struct {
	Gid   string                   `protobuf:"bytes,1,opt,name=gid" json:"gid,omitempty"`
	Label string                   `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	From  string                   `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
	To    string                   `protobuf:"bytes,4,opt,name=to" json:"to,omitempty"`
	Data  *google_protobuf1.Struct `protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
}

func (m *Edge) Reset()                    { *m = Edge{} }
func (m *Edge) String() string            { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()               {}
func (*Edge) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Edge) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *Edge) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Edge) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Edge) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Edge) GetData() *google_protobuf1.Struct {
	if m != nil {
		return m.Data
	}
	return nil
}

type QueryResult struct {
	// Types that are valid to be assigned to Result:
	//	*QueryResult_Vertex
	//	*QueryResult_Edge
	//	*QueryResult_Aggregations
	//	*QueryResult_Selections
	//	*QueryResult_Render
	//	*QueryResult_Count
	Result isQueryResult_Result `protobuf_oneof:"result"`
}

func (m *QueryResult) Reset()                    { *m = QueryResult{} }
func (m *QueryResult) String() string            { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()               {}
func (*QueryResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

type isQueryResult_Result interface{ isQueryResult_Result() }

type QueryResult_Vertex struct {
	Vertex *Vertex `protobuf:"bytes,1,opt,name=vertex,oneof"`
}
type QueryResult_Edge struct {
	Edge *Edge `protobuf:"bytes,2,opt,name=edge,oneof"`
}
type QueryResult_Aggregations struct {
	Aggregations *NamedAggregationResult `protobuf:"bytes,3,opt,name=aggregations,oneof"`
}
type QueryResult_Selections struct {
	Selections *Selections `protobuf:"bytes,4,opt,name=selections,oneof"`
}
type QueryResult_Render struct {
	Render *google_protobuf1.Value `protobuf:"bytes,5,opt,name=render,oneof"`
}
type QueryResult_Count struct {
	Count uint32 `protobuf:"varint,6,opt,name=count,oneof"`
}

func (*QueryResult_Vertex) isQueryResult_Result()       {}
func (*QueryResult_Edge) isQueryResult_Result()         {}
func (*QueryResult_Aggregations) isQueryResult_Result() {}
func (*QueryResult_Selections) isQueryResult_Result()   {}
func (*QueryResult_Render) isQueryResult_Result()       {}
func (*QueryResult_Count) isQueryResult_Result()        {}

func (m *QueryResult) GetResult() isQueryResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryResult) GetVertex() *Vertex {
	if x, ok := m.GetResult().(*QueryResult_Vertex); ok {
		return x.Vertex
	}
	return nil
}

func (m *QueryResult) GetEdge() *Edge {
	if x, ok := m.GetResult().(*QueryResult_Edge); ok {
		return x.Edge
	}
	return nil
}

func (m *QueryResult) GetAggregations() *NamedAggregationResult {
	if x, ok := m.GetResult().(*QueryResult_Aggregations); ok {
		return x.Aggregations
	}
	return nil
}

func (m *QueryResult) GetSelections() *Selections {
	if x, ok := m.GetResult().(*QueryResult_Selections); ok {
		return x.Selections
	}
	return nil
}

func (m *QueryResult) GetRender() *google_protobuf1.Value {
	if x, ok := m.GetResult().(*QueryResult_Render); ok {
		return x.Render
	}
	return nil
}

func (m *QueryResult) GetCount() uint32 {
	if x, ok := m.GetResult().(*QueryResult_Count); ok {
		return x.Count
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryResult_OneofMarshaler, _QueryResult_OneofUnmarshaler, _QueryResult_OneofSizer, []interface{}{
		(*QueryResult_Vertex)(nil),
		(*QueryResult_Edge)(nil),
		(*QueryResult_Aggregations)(nil),
		(*QueryResult_Selections)(nil),
		(*QueryResult_Render)(nil),
		(*QueryResult_Count)(nil),
	}
}

func _QueryResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryResult)
	// result
	switch x := m.Result.(type) {
	case *QueryResult_Vertex:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vertex); err != nil {
			return err
		}
	case *QueryResult_Edge:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Edge); err != nil {
			return err
		}
	case *QueryResult_Aggregations:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aggregations); err != nil {
			return err
		}
	case *QueryResult_Selections:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Selections); err != nil {
			return err
		}
	case *QueryResult_Render:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Render); err != nil {
			return err
		}
	case *QueryResult_Count:
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Count))
	case nil:
	default:
		return fmt.Errorf("QueryResult.Result has unexpected type %T", x)
	}
	return nil
}

func _QueryResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryResult)
	switch tag {
	case 1: // result.vertex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Vertex)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Vertex{msg}
		return true, err
	case 2: // result.edge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Edge)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Edge{msg}
		return true, err
	case 3: // result.aggregations
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NamedAggregationResult)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Aggregations{msg}
		return true, err
	case 4: // result.selections
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Selections)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Selections{msg}
		return true, err
	case 5: // result.render
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Value)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Render{msg}
		return true, err
	case 6: // result.count
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Result = &QueryResult_Count{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _QueryResult_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryResult)
	// result
	switch x := m.Result.(type) {
	case *QueryResult_Vertex:
		s := proto.Size(x.Vertex)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Edge:
		s := proto.Size(x.Edge)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Aggregations:
		s := proto.Size(x.Aggregations)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Selections:
		s := proto.Size(x.Selections)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Render:
		s := proto.Size(x.Render)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Count:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Count))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EditResult struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *EditResult) Reset()                    { *m = EditResult{} }
func (m *EditResult) String() string            { return proto.CompactTextString(m) }
func (*EditResult) ProtoMessage()               {}
func (*EditResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *EditResult) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GraphElement struct {
	Graph  string  `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Vertex *Vertex `protobuf:"bytes,2,opt,name=vertex" json:"vertex,omitempty"`
	Edge   *Edge   `protobuf:"bytes,3,opt,name=edge" json:"edge,omitempty"`
}

func (m *GraphElement) Reset()                    { *m = GraphElement{} }
func (m *GraphElement) String() string            { return proto.CompactTextString(m) }
func (*GraphElement) ProtoMessage()               {}
func (*GraphElement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *GraphElement) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *GraphElement) GetVertex() *Vertex {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *GraphElement) GetEdge() *Edge {
	if m != nil {
		return m.Edge
	}
	return nil
}

type GraphID struct {
	Graph string `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
}

func (m *GraphID) Reset()                    { *m = GraphID{} }
func (m *GraphID) String() string            { return proto.CompactTextString(m) }
func (*GraphID) ProtoMessage()               {}
func (*GraphID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GraphID) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

type ElementID struct {
	Graph string `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Id    string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *ElementID) Reset()                    { *m = ElementID{} }
func (m *ElementID) String() string            { return proto.CompactTextString(m) }
func (*ElementID) ProtoMessage()               {}
func (*ElementID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ElementID) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *ElementID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type IndexID struct {
	Graph string `protobuf:"bytes,1,opt,name=graph" json:"graph,omitempty"`
	Label string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	Field string `protobuf:"bytes,3,opt,name=field" json:"field,omitempty"`
}

func (m *IndexID) Reset()                    { *m = IndexID{} }
func (m *IndexID) String() string            { return proto.CompactTextString(m) }
func (*IndexID) ProtoMessage()               {}
func (*IndexID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *IndexID) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *IndexID) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *IndexID) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

type Timestamp struct {
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *Timestamp) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func init() {
	proto.RegisterType((*Graph)(nil), "aql.Graph")
	proto.RegisterType((*GraphQuery)(nil), "aql.GraphQuery")
	proto.RegisterType((*QuerySet)(nil), "aql.QuerySet")
	proto.RegisterType((*MatchQuerySet)(nil), "aql.MatchQuerySet")
	proto.RegisterType((*GraphStatement)(nil), "aql.GraphStatement")
	proto.RegisterType((*AggregationsRequest)(nil), "aql.AggregationsRequest")
	proto.RegisterType((*Aggregations)(nil), "aql.Aggregations")
	proto.RegisterType((*Aggregate)(nil), "aql.Aggregate")
	proto.RegisterType((*TermAggregation)(nil), "aql.TermAggregation")
	proto.RegisterType((*PercentileAggregation)(nil), "aql.PercentileAggregation")
	proto.RegisterType((*HistogramAggregation)(nil), "aql.HistogramAggregation")
	proto.RegisterType((*NamedAggregationResult)(nil), "aql.NamedAggregationResult")
	proto.RegisterType((*AggregationResult)(nil), "aql.AggregationResult")
	proto.RegisterType((*AggregationResultBucket)(nil), "aql.AggregationResultBucket")
	proto.RegisterType((*WhereExpressionList)(nil), "aql.WhereExpressionList")
	proto.RegisterType((*WhereExpression)(nil), "aql.WhereExpression")
	proto.RegisterType((*WhereCondition)(nil), "aql.WhereCondition")
	proto.RegisterType((*SelectStatement)(nil), "aql.SelectStatement")
	proto.RegisterType((*Selection)(nil), "aql.Selection")
	proto.RegisterType((*Selections)(nil), "aql.Selections")
	proto.RegisterType((*Vertex)(nil), "aql.Vertex")
	proto.RegisterType((*Edge)(nil), "aql.Edge")
	proto.RegisterType((*QueryResult)(nil), "aql.QueryResult")
	proto.RegisterType((*EditResult)(nil), "aql.EditResult")
	proto.RegisterType((*GraphElement)(nil), "aql.GraphElement")
	proto.RegisterType((*GraphID)(nil), "aql.GraphID")
	proto.RegisterType((*ElementID)(nil), "aql.ElementID")
	proto.RegisterType((*IndexID)(nil), "aql.IndexID")
	proto.RegisterType((*Timestamp)(nil), "aql.Timestamp")
	proto.RegisterType((*Empty)(nil), "aql.Empty")
	proto.RegisterEnum("aql.Condition", Condition_name, Condition_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Query service

type QueryClient interface {
	Traversal(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Query_TraversalClient, error)
	Aggregate(ctx context.Context, in *AggregationsRequest, opts ...grpc.CallOption) (*NamedAggregationResult, error)
	GetVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Vertex, error)
	GetEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Edge, error)
	GetTimestamp(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Timestamp, error)
	ListGraphs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Query_ListGraphsClient, error)
	ListIndices(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (Query_ListIndicesClient, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Traversal(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Query_TraversalClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[0], c.cc, "/aql.Query/Traversal", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryTraversalClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_TraversalClient interface {
	Recv() (*QueryResult, error)
	grpc.ClientStream
}

type queryTraversalClient struct {
	grpc.ClientStream
}

func (x *queryTraversalClient) Recv() (*QueryResult, error) {
	m := new(QueryResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) Aggregate(ctx context.Context, in *AggregationsRequest, opts ...grpc.CallOption) (*NamedAggregationResult, error) {
	out := new(NamedAggregationResult)
	err := grpc.Invoke(ctx, "/aql.Query/Aggregate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Vertex, error) {
	out := new(Vertex)
	err := grpc.Invoke(ctx, "/aql.Query/GetVertex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Edge, error) {
	out := new(Edge)
	err := grpc.Invoke(ctx, "/aql.Query/GetEdge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetTimestamp(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Timestamp, error) {
	out := new(Timestamp)
	err := grpc.Invoke(ctx, "/aql.Query/GetTimestamp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListGraphs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Query_ListGraphsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[1], c.cc, "/aql.Query/ListGraphs", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryListGraphsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_ListGraphsClient interface {
	Recv() (*GraphID, error)
	grpc.ClientStream
}

type queryListGraphsClient struct {
	grpc.ClientStream
}

func (x *queryListGraphsClient) Recv() (*GraphID, error) {
	m := new(GraphID)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) ListIndices(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (Query_ListIndicesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[2], c.cc, "/aql.Query/ListIndices", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryListIndicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_ListIndicesClient interface {
	Recv() (*IndexID, error)
	grpc.ClientStream
}

type queryListIndicesClient struct {
	grpc.ClientStream
}

func (x *queryListIndicesClient) Recv() (*IndexID, error) {
	m := new(IndexID)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Query service

type QueryServer interface {
	Traversal(*GraphQuery, Query_TraversalServer) error
	Aggregate(context.Context, *AggregationsRequest) (*NamedAggregationResult, error)
	GetVertex(context.Context, *ElementID) (*Vertex, error)
	GetEdge(context.Context, *ElementID) (*Edge, error)
	GetTimestamp(context.Context, *GraphID) (*Timestamp, error)
	ListGraphs(*Empty, Query_ListGraphsServer) error
	ListIndices(*GraphID, Query_ListIndicesServer) error
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Traversal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).Traversal(m, &queryTraversalServer{stream})
}

type Query_TraversalServer interface {
	Send(*QueryResult) error
	grpc.ServerStream
}

type queryTraversalServer struct {
	grpc.ServerStream
}

func (x *queryTraversalServer) Send(m *QueryResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_Aggregate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Aggregate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/Aggregate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Aggregate(ctx, req.(*AggregationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/GetVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetVertex(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/GetEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetEdge(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Query/GetTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetTimestamp(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListGraphs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).ListGraphs(m, &queryListGraphsServer{stream})
}

type Query_ListGraphsServer interface {
	Send(*GraphID) error
	grpc.ServerStream
}

type queryListGraphsServer struct {
	grpc.ServerStream
}

func (x *queryListGraphsServer) Send(m *GraphID) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_ListIndices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).ListIndices(m, &queryListIndicesServer{stream})
}

type Query_ListIndicesServer interface {
	Send(*IndexID) error
	grpc.ServerStream
}

type queryListIndicesServer struct {
	grpc.ServerStream
}

func (x *queryListIndicesServer) Send(m *IndexID) error {
	return x.ServerStream.SendMsg(m)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aql.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Aggregate",
			Handler:    _Query_Aggregate_Handler,
		},
		{
			MethodName: "GetVertex",
			Handler:    _Query_GetVertex_Handler,
		},
		{
			MethodName: "GetEdge",
			Handler:    _Query_GetEdge_Handler,
		},
		{
			MethodName: "GetTimestamp",
			Handler:    _Query_GetTimestamp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Traversal",
			Handler:       _Query_Traversal_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListGraphs",
			Handler:       _Query_ListGraphs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListIndices",
			Handler:       _Query_ListIndices_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aql.proto",
}

// Client API for Edit service

type EditClient interface {
	AddVertex(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error)
	AddEdge(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error)
	BulkAdd(ctx context.Context, opts ...grpc.CallOption) (Edit_BulkAddClient, error)
	AddGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	AddIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error)
}

type editClient struct {
	cc *grpc.ClientConn
}

func NewEditClient(cc *grpc.ClientConn) EditClient {
	return &editClient{cc}
}

func (c *editClient) AddVertex(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddVertex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddEdge(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddEdge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) BulkAdd(ctx context.Context, opts ...grpc.CallOption) (Edit_BulkAddClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Edit_serviceDesc.Streams[0], c.cc, "/aql.Edit/BulkAdd", opts...)
	if err != nil {
		return nil, err
	}
	x := &editBulkAddClient{stream}
	return x, nil
}

type Edit_BulkAddClient interface {
	Send(*GraphElement) error
	CloseAndRecv() (*EditResult, error)
	grpc.ClientStream
}

type editBulkAddClient struct {
	grpc.ClientStream
}

func (x *editBulkAddClient) Send(m *GraphElement) error {
	return x.ClientStream.SendMsg(m)
}

func (x *editBulkAddClient) CloseAndRecv() (*EditResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EditResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *editClient) AddGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteVertex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteEdge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/AddIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error) {
	out := new(EditResult)
	err := grpc.Invoke(ctx, "/aql.Edit/DeleteIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Edit service

type EditServer interface {
	AddVertex(context.Context, *GraphElement) (*EditResult, error)
	AddEdge(context.Context, *GraphElement) (*EditResult, error)
	BulkAdd(Edit_BulkAddServer) error
	AddGraph(context.Context, *GraphID) (*EditResult, error)
	DeleteGraph(context.Context, *GraphID) (*EditResult, error)
	DeleteVertex(context.Context, *ElementID) (*EditResult, error)
	DeleteEdge(context.Context, *ElementID) (*EditResult, error)
	AddIndex(context.Context, *IndexID) (*EditResult, error)
	DeleteIndex(context.Context, *IndexID) (*EditResult, error)
}

func RegisterEditServer(s *grpc.Server, srv EditServer) {
	s.RegisterService(&_Edit_serviceDesc, srv)
}

func _Edit_AddVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddVertex(ctx, req.(*GraphElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddEdge(ctx, req.(*GraphElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_BulkAdd_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EditServer).BulkAdd(&editBulkAddServer{stream})
}

type Edit_BulkAddServer interface {
	SendAndClose(*EditResult) error
	Recv() (*GraphElement, error)
	grpc.ServerStream
}

type editBulkAddServer struct {
	grpc.ServerStream
}

func (x *editBulkAddServer) SendAndClose(m *EditResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *editBulkAddServer) Recv() (*GraphElement, error) {
	m := new(GraphElement)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Edit_AddGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddGraph(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteGraph(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteVertex(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteEdge(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/AddIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddIndex(ctx, req.(*IndexID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aql.Edit/DeleteIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteIndex(ctx, req.(*IndexID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Edit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aql.Edit",
	HandlerType: (*EditServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddVertex",
			Handler:    _Edit_AddVertex_Handler,
		},
		{
			MethodName: "AddEdge",
			Handler:    _Edit_AddEdge_Handler,
		},
		{
			MethodName: "AddGraph",
			Handler:    _Edit_AddGraph_Handler,
		},
		{
			MethodName: "DeleteGraph",
			Handler:    _Edit_DeleteGraph_Handler,
		},
		{
			MethodName: "DeleteVertex",
			Handler:    _Edit_DeleteVertex_Handler,
		},
		{
			MethodName: "DeleteEdge",
			Handler:    _Edit_DeleteEdge_Handler,
		},
		{
			MethodName: "AddIndex",
			Handler:    _Edit_AddIndex_Handler,
		},
		{
			MethodName: "DeleteIndex",
			Handler:    _Edit_DeleteIndex_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BulkAdd",
			Handler:       _Edit_BulkAdd_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aql.proto",
}

func init() { proto.RegisterFile("aql.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1822 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdb, 0x6e, 0xdb, 0xc8,
	0x19, 0x36, 0xa9, 0x23, 0x7f, 0xc9, 0xb6, 0x3c, 0x76, 0x1c, 0x46, 0x71, 0xd6, 0xc6, 0x6c, 0xb6,
	0x71, 0xd4, 0xd4, 0x72, 0xbc, 0xdd, 0x6d, 0xea, 0x16, 0x28, 0xac, 0x58, 0xb0, 0x85, 0x24, 0x72,
	0x4d, 0x6b, 0x13, 0xec, 0x45, 0x1a, 0xd0, 0xe2, 0x58, 0x66, 0x4d, 0x91, 0x0e, 0x39, 0x52, 0x93,
	0x06, 0x69, 0x81, 0xbe, 0x42, 0x6f, 0x0b, 0xf4, 0x61, 0xda, 0x37, 0xc8, 0x4d, 0x1f, 0xa0, 0x77,
	0xbd, 0xe8, 0x2b, 0x14, 0x73, 0xe0, 0x49, 0x07, 0x87, 0x01, 0x7a, 0x65, 0xcd, 0xcc, 0xf7, 0x7f,
	0xf3, 0x9f, 0xe7, 0xa7, 0x41, 0x33, 0xdf, 0x3a, 0x3b, 0xd7, 0xbe, 0x47, 0x3d, 0x94, 0x33, 0xdf,
	0x3a, 0xf5, 0x8d, 0x81, 0xe7, 0x0d, 0x1c, 0xd2, 0x34, 0xaf, 0xed, 0xa6, 0xe9, 0xba, 0x1e, 0x35,
	0xa9, 0xed, 0xb9, 0x81, 0x80, 0x44, 0xa7, 0x7c, 0x75, 0x3e, 0xba, 0x68, 0x06, 0xd4, 0x1f, 0xf5,
	0xa9, 0x38, 0xc5, 0x03, 0x28, 0x1c, 0xf9, 0xe6, 0xf5, 0x25, 0x5a, 0x83, 0xc2, 0x80, 0xfd, 0xd0,
	0x95, 0x2d, 0x65, 0x5b, 0x33, 0xc4, 0x02, 0x3d, 0x80, 0xf2, 0x98, 0xf8, 0xd4, 0xee, 0x93, 0x40,
	0x57, 0xb7, 0x72, 0xdb, 0x95, 0xbd, 0xca, 0x0e, 0xbb, 0xfd, 0x25, 0xf1, 0x29, 0x79, 0x67, 0x44,
	0x87, 0x68, 0x13, 0x0a, 0xc4, 0x1a, 0x90, 0x40, 0xcf, 0x71, 0x94, 0xc6, 0x51, 0x6d, 0x6b, 0x40,
	0x0c, 0xb1, 0x8f, 0x5f, 0x00, 0xf0, 0x8b, 0x4e, 0x47, 0xc4, 0x7f, 0x3f, 0xe7, 0xb6, 0x87, 0x50,
	0x78, 0xcb, 0x8e, 0xe5, 0x55, 0xab, 0x9c, 0x84, 0x4b, 0x9d, 0x51, 0x93, 0x92, 0x21, 0x71, 0xa9,
	0x21, 0x10, 0xf8, 0x3b, 0x28, 0x73, 0xa6, 0x33, 0x42, 0x63, 0x31, 0xe5, 0xb3, 0x62, 0x4f, 0x60,
	0xf1, 0x85, 0x49, 0xfb, 0x97, 0x91, 0xec, 0x03, 0x28, 0xb1, 0x13, 0x9b, 0x04, 0x52, 0x7a, 0x91,
	0x4b, 0x87, 0xe7, 0x46, 0x78, 0x8a, 0xff, 0x5b, 0x84, 0xa5, 0x34, 0x27, 0x6a, 0x80, 0x32, 0xe6,
	0x06, 0x54, 0xf6, 0xea, 0x3b, 0xc2, 0xcb, 0x3b, 0xa1, 0x97, 0x77, 0x9e, 0xdb, 0x01, 0x7d, 0x69,
	0x3a, 0x23, 0x72, 0xbc, 0x60, 0x28, 0x63, 0x86, 0x25, 0xba, 0x9a, 0x05, 0x4b, 0xd0, 0x23, 0x50,
	0x6d, 0x57, 0x87, 0x0c, 0x60, 0xd5, 0x76, 0xd1, 0x0e, 0xe4, 0xbc, 0x11, 0xd5, 0x2b, 0x19, 0xe0,
	0x0c, 0x88, 0xbe, 0x83, 0x92, 0xed, 0xbe, 0x61, 0x41, 0xd1, 0xab, 0x19, 0x64, 0x8a, 0xb6, 0xcb,
	0xc2, 0x88, 0x7e, 0x01, 0x65, 0x6f, 0x44, 0x85, 0xdc, 0x62, 0x06, 0xb9, 0x92, 0x37, 0xa2, 0x5c,
	0x70, 0x17, 0xf2, 0xe7, 0x1e, 0xbd, 0xd4, 0x97, 0x32, 0x08, 0x71, 0x24, 0xfa, 0x25, 0x68, 0xec,
	0xaf, 0xb8, 0x6b, 0x39, 0x83, 0x58, 0x99, 0xc1, 0xf9, 0x65, 0x6b, 0x90, 0x1f, 0x9a, 0xfe, 0x95,
	0xbe, 0xc6, 0xd2, 0x8a, 0x11, 0xb2, 0x15, 0xda, 0x81, 0x62, 0x40, 0x1c, 0xd2, 0xa7, 0xfa, 0x2d,
	0xce, 0xb6, 0xc6, 0x63, 0x7c, 0xc6, 0xb7, 0xa2, 0x70, 0x32, 0x5b, 0x05, 0x0a, 0xad, 0x43, 0xc1,
	0xb1, 0x87, 0x36, 0xd5, 0xf5, 0x2d, 0x65, 0x7b, 0xf1, 0x78, 0xc1, 0x10, 0x4b, 0xa4, 0x43, 0xd1,
	0xbb, 0xb8, 0x08, 0x08, 0xd5, 0xef, 0xc8, 0x03, 0xb9, 0x46, 0x3f, 0x87, 0xe2, 0x85, 0x4d, 0x1c,
	0x2b, 0xd0, 0xeb, 0x59, 0x7c, 0x2a, 0xb0, 0xe8, 0x09, 0x94, 0x2d, 0x3b, 0xa0, 0xb6, 0xdb, 0xa7,
	0xfa, 0xdd, 0x2c, 0x76, 0x86, 0x68, 0xd4, 0x80, 0xc2, 0x90, 0xe5, 0xb1, 0xbe, 0xc1, 0xc5, 0x10,
	0x37, 0x28, 0x95, 0xd9, 0x4c, 0x6b, 0x0e, 0x41, 0x8f, 0xa0, 0xf0, 0x87, 0x4b, 0xe2, 0x13, 0xfd,
	0x5e, 0xc2, 0xf8, 0x57, 0x6c, 0xa7, 0xfd, 0xee, 0xda, 0x27, 0x41, 0x60, 0x7b, 0x2e, 0x43, 0x73,
	0x10, 0xb3, 0xbd, 0xef, 0x8d, 0x5c, 0xaa, 0x7f, 0x25, 0x5d, 0x28, 0x96, 0xe8, 0x31, 0x68, 0xe6,
	0x60, 0xe0, 0x93, 0x81, 0x49, 0x89, 0xbe, 0xc9, 0x99, 0x56, 0x38, 0xd3, 0x81, 0xdc, 0x65, 0x2d,
	0xe7, 0x78, 0xc1, 0x88, 0x51, 0x68, 0x17, 0x8a, 0x3e, 0x71, 0x2d, 0xe2, 0xeb, 0x5b, 0x1c, 0xbf,
	0x3e, 0x65, 0x5c, 0xe4, 0x10, 0x81, 0x6b, 0x55, 0x40, 0x0b, 0xc2, 0x78, 0xe0, 0x37, 0xb0, 0x9a,
	0xe4, 0x36, 0xc8, 0xdb, 0x11, 0x09, 0xe8, 0x9c, 0xd6, 0xb1, 0x07, 0x55, 0x33, 0x01, 0x96, 0x1d,
	0x64, 0x29, 0xa5, 0x21, 0x31, 0x52, 0x18, 0xdc, 0x82, 0x6a, 0xf2, 0x82, 0x29, 0x0e, 0x25, 0x03,
	0xc7, 0x27, 0x05, 0xb4, 0xe8, 0x0c, 0x21, 0xc8, 0xbb, 0xe6, 0x90, 0x48, 0xd5, 0xf8, 0x6f, 0xd4,
	0x80, 0x3c, 0x25, 0xfe, 0x50, 0x16, 0xbf, 0xf0, 0x7e, 0x8f, 0xf8, 0xc3, 0xc4, 0xd5, 0x2c, 0x51,
	0x19, 0x06, 0xfd, 0x1a, 0xe0, 0x9a, 0xf8, 0x7d, 0xe2, 0x52, 0xdb, 0x21, 0x7a, 0x4e, 0xa6, 0x04,
	0x93, 0xf8, 0x6d, 0xb4, 0x9d, 0x96, 0x4b, 0xe0, 0x59, 0xdd, 0x5c, 0xda, 0x01, 0xf5, 0x06, 0xbe,
	0x39, 0xd4, 0xf3, 0x5c, 0xf8, 0x0e, 0x17, 0x3e, 0x0e, 0x77, 0xd3, 0xb2, 0x31, 0xba, 0xb5, 0x08,
	0x95, 0x84, 0x59, 0xf8, 0x14, 0x96, 0x27, 0x54, 0x64, 0x6e, 0x77, 0xcc, 0x73, 0xe2, 0x84, 0x6e,
	0xe7, 0x0b, 0xb6, 0xcb, 0x73, 0x99, 0x5b, 0xa7, 0x19, 0x62, 0xc1, 0xdc, 0x10, 0xd8, 0x7f, 0x14,
	0x06, 0x2c, 0x1a, 0xfc, 0x37, 0x7e, 0x03, 0xb7, 0x66, 0xda, 0xf0, 0x45, 0xc4, 0x75, 0x28, 0x4b,
	0x7b, 0xc5, 0x43, 0xa3, 0x18, 0xd1, 0x1a, 0xff, 0x0e, 0xd6, 0x66, 0xd9, 0xf9, 0xa5, 0xfc, 0xb6,
	0x4b, 0x89, 0x3f, 0x36, 0x1d, 0xa9, 0x7c, 0xb4, 0xc6, 0xff, 0x54, 0x60, 0xbd, 0x6b, 0x0e, 0x89,
	0x95, 0x20, 0x37, 0x48, 0x30, 0x72, 0x28, 0x3a, 0x9d, 0x48, 0x1c, 0xf1, 0x06, 0xfe, 0x8c, 0xfb,
	0x7e, 0xb6, 0x48, 0xaa, 0x6a, 0xda, 0x2e, 0xf5, 0xdf, 0xa7, 0xf3, 0xaa, 0xfe, 0x0a, 0x56, 0xa6,
	0x20, 0xa8, 0x06, 0xb9, 0x2b, 0xf2, 0x5e, 0x1a, 0xc2, 0x7e, 0xb2, 0xda, 0x1e, 0xb3, 0x1a, 0x92,
	0xd9, 0xb5, 0x3e, 0x59, 0x91, 0xe2, 0x36, 0x43, 0x80, 0xf6, 0xd5, 0x27, 0x0a, 0x7e, 0x96, 0x22,
	0x96, 0x06, 0x7c, 0x0f, 0xa5, 0xf3, 0x51, 0xff, 0x8a, 0xd0, 0xb0, 0x70, 0x36, 0x66, 0x13, 0xb5,
	0x38, 0xc8, 0x08, 0xc1, 0xf8, 0x47, 0xb8, 0x3d, 0x07, 0x83, 0xb6, 0x63, 0x5d, 0xe7, 0x56, 0xbe,
	0xb0, 0x61, 0x2d, 0x69, 0x83, 0x22, 0x75, 0xc5, 0x2f, 0x60, 0x75, 0xa2, 0x47, 0xb1, 0x4e, 0x88,
	0xbe, 0x87, 0x0a, 0x89, 0x76, 0xc2, 0x12, 0x9d, 0xd9, 0xd2, 0x8c, 0x24, 0x10, 0xff, 0x4b, 0x81,
	0xe5, 0x09, 0x00, 0x7a, 0x04, 0x39, 0xd3, 0xb5, 0xa4, 0x8a, 0xfa, 0x2c, 0x0e, 0x76, 0x25, 0x7b,
	0x37, 0x4d, 0xd7, 0x42, 0x0d, 0x50, 0x3d, 0x5f, 0xfa, 0xf9, 0x26, 0xb0, 0xea, 0xf9, 0xcc, 0x78,
	0xd7, 0xa3, 0xb2, 0x80, 0xe7, 0x35, 0x5c, 0x06, 0x41, 0xdf, 0x82, 0xd6, 0xf7, 0x5c, 0xcb, 0x66,
	0xfe, 0x93, 0x35, 0xbb, 0x1a, 0xe3, 0x9f, 0x86, 0x47, 0xac, 0x5a, 0x23, 0x5c, 0xab, 0x0a, 0x10,
	0xdb, 0x86, 0xff, 0x04, 0x4b, 0x69, 0x70, 0x96, 0x3c, 0x99, 0x1d, 0x0f, 0x01, 0x42, 0x8f, 0x92,
	0x4a, 0x31, 0x23, 0x96, 0x64, 0x17, 0x8c, 0xae, 0x48, 0x68, 0x83, 0x1f, 0xc0, 0xf2, 0xc4, 0x53,
	0xca, 0x42, 0xca, 0x1e, 0x5e, 0x11, 0x1f, 0xcd, 0x10, 0x0b, 0xfc, 0x1a, 0x34, 0x01, 0x64, 0x3a,
	0x7e, 0x03, 0xc5, 0x31, 0x1f, 0x22, 0xa5, 0xff, 0x93, 0x73, 0x25, 0x7b, 0x11, 0xc4, 0x21, 0xda,
	0x84, 0x3c, 0x1f, 0x03, 0x84, 0xde, 0xf1, 0x58, 0xc9, 0x5a, 0x26, 0x3b, 0x68, 0x95, 0xd9, 0x23,
	0xc3, 0xf2, 0x0e, 0xff, 0x4d, 0x01, 0x88, 0xf8, 0x03, 0xf4, 0x1b, 0x80, 0x20, 0x5a, 0xc9, 0x44,
	0xd9, 0x4c, 0x3c, 0xfc, 0x7c, 0x44, 0x8e, 0x7f, 0x8a, 0x22, 0x4c, 0x88, 0xd4, 0x5f, 0x84, 0x76,
	0xdd, 0x54, 0x80, 0xf7, 0xd3, 0x8e, 0x5d, 0x4a, 0x5f, 0x90, 0x2c, 0xbc, 0xd7, 0x50, 0x14, 0xd6,
	0x31, 0x96, 0x81, 0x6d, 0x85, 0x2c, 0x03, 0xdb, 0x8a, 0x7b, 0x94, 0x9a, 0xec, 0x51, 0x3f, 0x85,
	0xbc, 0x65, 0x52, 0x53, 0xa6, 0xd1, 0xed, 0xa9, 0x98, 0x9d, 0xf1, 0x41, 0xde, 0xe0, 0x20, 0xfc,
	0x67, 0xc8, 0xf3, 0x09, 0x28, 0x2b, 0x39, 0x82, 0xfc, 0x85, 0xef, 0x0d, 0x39, 0xb9, 0x66, 0xf0,
	0xdf, 0x68, 0x09, 0x54, 0xea, 0xf1, 0x2c, 0xd4, 0x0c, 0x95, 0x7a, 0x91, 0x02, 0x85, 0x2c, 0x0a,
	0xfc, 0x5d, 0x85, 0x0a, 0x1f, 0x3e, 0x64, 0x4f, 0xf9, 0x3f, 0x05, 0x18, 0x1d, 0x4c, 0x35, 0x57,
	0x06, 0xbc, 0x7b, 0x43, 0x73, 0x3d, 0x5e, 0x48, 0x37, 0x53, 0xf4, 0x38, 0x95, 0x0a, 0xa2, 0xca,
	0x96, 0x27, 0x52, 0x81, 0xbd, 0xa5, 0x31, 0x28, 0x31, 0xbb, 0x14, 0xb2, 0xcd, 0x2e, 0xf1, 0xe0,
	0x54, 0x0c, 0x87, 0x46, 0xbe, 0x4c, 0x24, 0xe8, 0x06, 0x40, 0xdb, 0xb2, 0xa9, 0xf4, 0xcf, 0x12,
	0xa8, 0x51, 0x9c, 0x54, 0xdb, 0xc2, 0x97, 0x50, 0xe5, 0xdf, 0x17, 0x6d, 0x27, 0xaa, 0xa1, 0x19,
	0x73, 0xce, 0xd7, 0x91, 0x57, 0xd5, 0x29, 0xaf, 0x46, 0x3e, 0xbd, 0x27, 0x7d, 0x9a, 0x9b, 0xf0,
	0xa9, 0xf0, 0x28, 0xde, 0x84, 0x12, 0xbf, 0xa9, 0x73, 0x38, 0xfb, 0x12, 0xfc, 0x18, 0x34, 0xa9,
	0xc5, 0x3c, 0x88, 0xd4, 0x5e, 0x8d, 0xb4, 0x7f, 0x06, 0xa5, 0x8e, 0x6b, 0x91, 0x77, 0x73, 0x05,
	0x66, 0x67, 0x61, 0xf4, 0x0c, 0xe7, 0x12, 0xcf, 0x30, 0x7e, 0x08, 0x5a, 0xcf, 0x1e, 0x92, 0x80,
	0x9a, 0xc3, 0x6b, 0xb4, 0x01, 0x1a, 0x0d, 0x17, 0x92, 0x32, 0xde, 0xc0, 0x25, 0x28, 0xb4, 0x87,
	0xd7, 0xf4, 0x7d, 0xe3, 0x0a, 0xb4, 0xb8, 0x01, 0xde, 0x82, 0x95, 0x1f, 0xba, 0xcf, 0xba, 0x27,
	0xaf, 0xba, 0x6f, 0x9e, 0x9e, 0x74, 0x0f, 0x3b, 0xbd, 0xce, 0x49, 0xb7, 0xb6, 0x80, 0x8a, 0xa0,
	0xb6, 0x4f, 0x6b, 0x0a, 0x2a, 0x41, 0xae, 0xdb, 0x3e, 0xad, 0xa9, 0x6c, 0xe3, 0xa8, 0x57, 0xcb,
	0xb1, 0x8d, 0xa3, 0x5e, 0xbb, 0x96, 0x67, 0x1b, 0xcf, 0x7b, 0xb5, 0x02, 0xdb, 0x78, 0xde, 0x6b,
	0xd7, 0x8a, 0x6c, 0xa3, 0xd3, 0xad, 0x95, 0x50, 0x15, 0xca, 0x4f, 0x4f, 0xba, 0xbd, 0x83, 0x4e,
	0xf7, 0xac, 0x56, 0xde, 0xfb, 0x47, 0x1e, 0x0a, 0xe2, 0x43, 0xb6, 0x07, 0x5a, 0xcf, 0x37, 0xc7,
	0xc4, 0x0f, 0x4c, 0x07, 0x2d, 0xc7, 0x5f, 0x9e, 0xfc, 0xb4, 0x5e, 0x8b, 0x3f, 0x26, 0x45, 0xd4,
	0x31, 0xfe, 0xcb, 0xa7, 0x7f, 0xff, 0x55, 0xdd, 0xc0, 0xb7, 0x9b, 0xe3, 0xc7, 0x4d, 0xee, 0x99,
	0xe6, 0x07, 0xfe, 0xe7, 0x63, 0x93, 0x7f, 0xa1, 0xee, 0x2b, 0x8d, 0x5d, 0x05, 0xfd, 0x3e, 0x39,
	0x54, 0xea, 0x53, 0x63, 0xb6, 0x1c, 0x85, 0xeb, 0x37, 0x15, 0x01, 0xfe, 0x09, 0xbf, 0x69, 0x0b,
	0xdf, 0x9d, 0xbe, 0x29, 0x1a, 0xd1, 0xf7, 0x95, 0x06, 0x3a, 0x01, 0xed, 0x88, 0x50, 0xd9, 0x9a,
	0x44, 0xff, 0x8a, 0x82, 0x5f, 0x4f, 0xa6, 0x17, 0xfe, 0x86, 0x33, 0x6e, 0xa2, 0x7b, 0xd3, 0x8c,
	0x22, 0xf1, 0x9a, 0x1f, 0x6c, 0xeb, 0x23, 0xea, 0x40, 0xe9, 0x88, 0x88, 0x6f, 0xbf, 0x49, 0xba,
	0x38, 0x15, 0xf1, 0xd7, 0x9c, 0xec, 0x1e, 0x9a, 0xa1, 0x1e, 0x4b, 0x52, 0x41, 0x75, 0x0a, 0xd5,
	0x23, 0x42, 0xe3, 0x5c, 0xa8, 0xc6, 0x0e, 0xee, 0x1c, 0xd6, 0x05, 0x7b, 0x74, 0x7a, 0x13, 0x65,
	0x94, 0x30, 0xe8, 0x57, 0x00, 0xec, 0xa1, 0xe6, 0x1c, 0x01, 0x02, 0xa1, 0x10, 0xcb, 0xa0, 0x7a,
	0x8a, 0x1c, 0xaf, 0x70, 0xb2, 0x0a, 0xd2, 0x22, 0xb2, 0x5d, 0x05, 0x3d, 0x87, 0x0a, 0x13, 0xee,
	0xb8, 0x16, 0xff, 0xa7, 0x47, 0x5a, 0x1d, 0xb1, 0x92, 0x55, 0x80, 0x37, 0xb9, 0xfc, 0x1d, 0x34,
	0x23, 0xd0, 0x36, 0x83, 0xec, 0x2a, 0x7b, 0xff, 0x29, 0xb0, 0x9e, 0x6d, 0x53, 0xf4, 0x23, 0x68,
	0x07, 0x96, 0x25, 0x43, 0xb0, 0x12, 0x93, 0x4a, 0xc7, 0xd5, 0x97, 0xa5, 0xdb, 0xc2, 0xde, 0x81,
	0xb7, 0x39, 0x39, 0xc6, 0xfa, 0xbc, 0x48, 0xec, 0x87, 0xad, 0xe0, 0x0c, 0x4a, 0x07, 0x96, 0xc5,
	0x83, 0x91, 0x85, 0xf8, 0x3e, 0x27, 0xfe, 0x0a, 0xaf, 0xcf, 0x8e, 0xca, 0xbe, 0x68, 0xc9, 0x2d,
	0x28, 0xb5, 0x46, 0xce, 0xd5, 0x81, 0x65, 0x65, 0x22, 0x95, 0xae, 0xc4, 0xb1, 0x2b, 0xb7, 0x15,
	0x74, 0x08, 0xe5, 0x03, 0xcb, 0x12, 0xff, 0x7b, 0x4a, 0xfb, 0x71, 0x4a, 0xfe, 0x0e, 0x97, 0x5f,
	0xc5, 0x2b, 0x53, 0x4a, 0xa1, 0x23, 0xa8, 0x1c, 0x12, 0x87, 0x50, 0xf2, 0x25, 0x44, 0x8d, 0x19,
	0x44, 0x2f, 0xa1, 0x2a, 0x88, 0xe6, 0x14, 0xc2, 0x14, 0x97, 0x2c, 0x86, 0xc6, 0x67, 0x8a, 0xc1,
	0x00, 0x10, 0xbc, 0x33, 0xeb, 0x61, 0x8a, 0x55, 0xa6, 0x70, 0xe3, 0xc6, 0xaa, 0xf8, 0x81, 0xbb,
	0x8e, 0x27, 0x1a, 0x4a, 0x25, 0xdd, 0x34, 0x5f, 0x83, 0xf3, 0xdd, 0xc7, 0x9b, 0x73, 0xb2, 0xb0,
	0xf9, 0x81, 0xf7, 0xe1, 0x8f, 0xac, 0x11, 0xbc, 0x0e, 0x7d, 0x99, 0x89, 0xb9, 0xc9, 0x99, 0x1f,
	0x36, 0x1e, 0x7c, 0x86, 0xb9, 0xf9, 0x81, 0xf7, 0xf4, 0x8f, 0xe7, 0x45, 0xfe, 0x72, 0x7e, 0xfb,
	0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x51, 0xd5, 0x8c, 0xbe, 0x14, 0x00, 0x00,
}
