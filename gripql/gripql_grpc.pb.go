// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.27.1
// source: gripql.proto

package gripql

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	Query_Traversal_FullMethodName    = "/gripql.Query/Traversal"
	Query_GetVertex_FullMethodName    = "/gripql.Query/GetVertex"
	Query_GetEdge_FullMethodName      = "/gripql.Query/GetEdge"
	Query_GetTimestamp_FullMethodName = "/gripql.Query/GetTimestamp"
	Query_GetSchema_FullMethodName    = "/gripql.Query/GetSchema"
	Query_GetMapping_FullMethodName   = "/gripql.Query/GetMapping"
	Query_ListGraphs_FullMethodName   = "/gripql.Query/ListGraphs"
	Query_ListIndices_FullMethodName  = "/gripql.Query/ListIndices"
	Query_ListLabels_FullMethodName   = "/gripql.Query/ListLabels"
	Query_ListTables_FullMethodName   = "/gripql.Query/ListTables"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	Traversal(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Query_TraversalClient, error)
	GetVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Vertex, error)
	GetEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Edge, error)
	GetTimestamp(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Timestamp, error)
	GetSchema(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Graph, error)
	GetMapping(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Graph, error)
	ListGraphs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListGraphsResponse, error)
	ListIndices(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*ListIndicesResponse, error)
	ListLabels(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*ListLabelsResponse, error)
	ListTables(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Query_ListTablesClient, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Traversal(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Query_TraversalClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[0], Query_Traversal_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &queryTraversalClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_TraversalClient interface {
	Recv() (*QueryResult, error)
	grpc.ClientStream
}

type queryTraversalClient struct {
	grpc.ClientStream
}

func (x *queryTraversalClient) Recv() (*QueryResult, error) {
	m := new(QueryResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) GetVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Vertex, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Vertex)
	err := c.cc.Invoke(ctx, Query_GetVertex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*Edge, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Edge)
	err := c.cc.Invoke(ctx, Query_GetEdge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetTimestamp(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Timestamp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Timestamp)
	err := c.cc.Invoke(ctx, Query_GetTimestamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetSchema(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Graph, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Graph)
	err := c.cc.Invoke(ctx, Query_GetSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetMapping(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Graph, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Graph)
	err := c.cc.Invoke(ctx, Query_GetMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListGraphs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListGraphsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGraphsResponse)
	err := c.cc.Invoke(ctx, Query_ListGraphs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListIndices(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*ListIndicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListIndicesResponse)
	err := c.cc.Invoke(ctx, Query_ListIndices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListLabels(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*ListLabelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLabelsResponse)
	err := c.cc.Invoke(ctx, Query_ListLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ListTables(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Query_ListTablesClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[1], Query_ListTables_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &queryListTablesClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_ListTablesClient interface {
	Recv() (*TableInfo, error)
	grpc.ClientStream
}

type queryListTablesClient struct {
	grpc.ClientStream
}

func (x *queryListTablesClient) Recv() (*TableInfo, error) {
	m := new(TableInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	Traversal(*GraphQuery, Query_TraversalServer) error
	GetVertex(context.Context, *ElementID) (*Vertex, error)
	GetEdge(context.Context, *ElementID) (*Edge, error)
	GetTimestamp(context.Context, *GraphID) (*Timestamp, error)
	GetSchema(context.Context, *GraphID) (*Graph, error)
	GetMapping(context.Context, *GraphID) (*Graph, error)
	ListGraphs(context.Context, *Empty) (*ListGraphsResponse, error)
	ListIndices(context.Context, *GraphID) (*ListIndicesResponse, error)
	ListLabels(context.Context, *GraphID) (*ListLabelsResponse, error)
	ListTables(*Empty, Query_ListTablesServer) error
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) Traversal(*GraphQuery, Query_TraversalServer) error {
	return status.Errorf(codes.Unimplemented, "method Traversal not implemented")
}
func (UnimplementedQueryServer) GetVertex(context.Context, *ElementID) (*Vertex, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVertex not implemented")
}
func (UnimplementedQueryServer) GetEdge(context.Context, *ElementID) (*Edge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEdge not implemented")
}
func (UnimplementedQueryServer) GetTimestamp(context.Context, *GraphID) (*Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimestamp not implemented")
}
func (UnimplementedQueryServer) GetSchema(context.Context, *GraphID) (*Graph, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchema not implemented")
}
func (UnimplementedQueryServer) GetMapping(context.Context, *GraphID) (*Graph, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMapping not implemented")
}
func (UnimplementedQueryServer) ListGraphs(context.Context, *Empty) (*ListGraphsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGraphs not implemented")
}
func (UnimplementedQueryServer) ListIndices(context.Context, *GraphID) (*ListIndicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListIndices not implemented")
}
func (UnimplementedQueryServer) ListLabels(context.Context, *GraphID) (*ListLabelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLabels not implemented")
}
func (UnimplementedQueryServer) ListTables(*Empty, Query_ListTablesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTables not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_Traversal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).Traversal(m, &queryTraversalServer{ServerStream: stream})
}

type Query_TraversalServer interface {
	Send(*QueryResult) error
	grpc.ServerStream
}

type queryTraversalServer struct {
	grpc.ServerStream
}

func (x *queryTraversalServer) Send(m *QueryResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_GetVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_GetVertex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetVertex(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_GetEdge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetEdge(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_GetTimestamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetTimestamp(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_GetSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetSchema(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_GetMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetMapping(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListGraphs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListGraphs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_ListGraphs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListGraphs(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListIndices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListIndices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_ListIndices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListIndices(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ListLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_ListLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ListLabels(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ListTables_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).ListTables(m, &queryListTablesServer{ServerStream: stream})
}

type Query_ListTablesServer interface {
	Send(*TableInfo) error
	grpc.ServerStream
}

type queryListTablesServer struct {
	grpc.ServerStream
}

func (x *queryListTablesServer) Send(m *TableInfo) error {
	return x.ServerStream.SendMsg(m)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gripql.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVertex",
			Handler:    _Query_GetVertex_Handler,
		},
		{
			MethodName: "GetEdge",
			Handler:    _Query_GetEdge_Handler,
		},
		{
			MethodName: "GetTimestamp",
			Handler:    _Query_GetTimestamp_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _Query_GetSchema_Handler,
		},
		{
			MethodName: "GetMapping",
			Handler:    _Query_GetMapping_Handler,
		},
		{
			MethodName: "ListGraphs",
			Handler:    _Query_ListGraphs_Handler,
		},
		{
			MethodName: "ListIndices",
			Handler:    _Query_ListIndices_Handler,
		},
		{
			MethodName: "ListLabels",
			Handler:    _Query_ListLabels_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Traversal",
			Handler:       _Query_Traversal_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTables",
			Handler:       _Query_ListTables_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gripql.proto",
}

const (
	Job_Submit_FullMethodName     = "/gripql.Job/Submit"
	Job_ListJobs_FullMethodName   = "/gripql.Job/ListJobs"
	Job_SearchJobs_FullMethodName = "/gripql.Job/SearchJobs"
	Job_DeleteJob_FullMethodName  = "/gripql.Job/DeleteJob"
	Job_GetJob_FullMethodName     = "/gripql.Job/GetJob"
	Job_ViewJob_FullMethodName    = "/gripql.Job/ViewJob"
	Job_ResumeJob_FullMethodName  = "/gripql.Job/ResumeJob"
)

// JobClient is the client API for Job service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobClient interface {
	Submit(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (*QueryJob, error)
	ListJobs(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (Job_ListJobsClient, error)
	SearchJobs(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Job_SearchJobsClient, error)
	DeleteJob(ctx context.Context, in *QueryJob, opts ...grpc.CallOption) (*JobStatus, error)
	GetJob(ctx context.Context, in *QueryJob, opts ...grpc.CallOption) (*JobStatus, error)
	ViewJob(ctx context.Context, in *QueryJob, opts ...grpc.CallOption) (Job_ViewJobClient, error)
	ResumeJob(ctx context.Context, in *ExtendQuery, opts ...grpc.CallOption) (Job_ResumeJobClient, error)
}

type jobClient struct {
	cc grpc.ClientConnInterface
}

func NewJobClient(cc grpc.ClientConnInterface) JobClient {
	return &jobClient{cc}
}

func (c *jobClient) Submit(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (*QueryJob, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryJob)
	err := c.cc.Invoke(ctx, Job_Submit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobClient) ListJobs(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (Job_ListJobsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Job_ServiceDesc.Streams[0], Job_ListJobs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &jobListJobsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Job_ListJobsClient interface {
	Recv() (*QueryJob, error)
	grpc.ClientStream
}

type jobListJobsClient struct {
	grpc.ClientStream
}

func (x *jobListJobsClient) Recv() (*QueryJob, error) {
	m := new(QueryJob)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *jobClient) SearchJobs(ctx context.Context, in *GraphQuery, opts ...grpc.CallOption) (Job_SearchJobsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Job_ServiceDesc.Streams[1], Job_SearchJobs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &jobSearchJobsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Job_SearchJobsClient interface {
	Recv() (*JobStatus, error)
	grpc.ClientStream
}

type jobSearchJobsClient struct {
	grpc.ClientStream
}

func (x *jobSearchJobsClient) Recv() (*JobStatus, error) {
	m := new(JobStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *jobClient) DeleteJob(ctx context.Context, in *QueryJob, opts ...grpc.CallOption) (*JobStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, Job_DeleteJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobClient) GetJob(ctx context.Context, in *QueryJob, opts ...grpc.CallOption) (*JobStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, Job_GetJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobClient) ViewJob(ctx context.Context, in *QueryJob, opts ...grpc.CallOption) (Job_ViewJobClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Job_ServiceDesc.Streams[2], Job_ViewJob_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &jobViewJobClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Job_ViewJobClient interface {
	Recv() (*QueryResult, error)
	grpc.ClientStream
}

type jobViewJobClient struct {
	grpc.ClientStream
}

func (x *jobViewJobClient) Recv() (*QueryResult, error) {
	m := new(QueryResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *jobClient) ResumeJob(ctx context.Context, in *ExtendQuery, opts ...grpc.CallOption) (Job_ResumeJobClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Job_ServiceDesc.Streams[3], Job_ResumeJob_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &jobResumeJobClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Job_ResumeJobClient interface {
	Recv() (*QueryResult, error)
	grpc.ClientStream
}

type jobResumeJobClient struct {
	grpc.ClientStream
}

func (x *jobResumeJobClient) Recv() (*QueryResult, error) {
	m := new(QueryResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// JobServer is the server API for Job service.
// All implementations must embed UnimplementedJobServer
// for forward compatibility
type JobServer interface {
	Submit(context.Context, *GraphQuery) (*QueryJob, error)
	ListJobs(*GraphID, Job_ListJobsServer) error
	SearchJobs(*GraphQuery, Job_SearchJobsServer) error
	DeleteJob(context.Context, *QueryJob) (*JobStatus, error)
	GetJob(context.Context, *QueryJob) (*JobStatus, error)
	ViewJob(*QueryJob, Job_ViewJobServer) error
	ResumeJob(*ExtendQuery, Job_ResumeJobServer) error
	mustEmbedUnimplementedJobServer()
}

// UnimplementedJobServer must be embedded to have forward compatible implementations.
type UnimplementedJobServer struct {
}

func (UnimplementedJobServer) Submit(context.Context, *GraphQuery) (*QueryJob, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Submit not implemented")
}
func (UnimplementedJobServer) ListJobs(*GraphID, Job_ListJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedJobServer) SearchJobs(*GraphQuery, Job_SearchJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchJobs not implemented")
}
func (UnimplementedJobServer) DeleteJob(context.Context, *QueryJob) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (UnimplementedJobServer) GetJob(context.Context, *QueryJob) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedJobServer) ViewJob(*QueryJob, Job_ViewJobServer) error {
	return status.Errorf(codes.Unimplemented, "method ViewJob not implemented")
}
func (UnimplementedJobServer) ResumeJob(*ExtendQuery, Job_ResumeJobServer) error {
	return status.Errorf(codes.Unimplemented, "method ResumeJob not implemented")
}
func (UnimplementedJobServer) mustEmbedUnimplementedJobServer() {}

// UnsafeJobServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServer will
// result in compilation errors.
type UnsafeJobServer interface {
	mustEmbedUnimplementedJobServer()
}

func RegisterJobServer(s grpc.ServiceRegistrar, srv JobServer) {
	s.RegisterService(&Job_ServiceDesc, srv)
}

func _Job_Submit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServer).Submit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Job_Submit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServer).Submit(ctx, req.(*GraphQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Job_ListJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServer).ListJobs(m, &jobListJobsServer{ServerStream: stream})
}

type Job_ListJobsServer interface {
	Send(*QueryJob) error
	grpc.ServerStream
}

type jobListJobsServer struct {
	grpc.ServerStream
}

func (x *jobListJobsServer) Send(m *QueryJob) error {
	return x.ServerStream.SendMsg(m)
}

func _Job_SearchJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServer).SearchJobs(m, &jobSearchJobsServer{ServerStream: stream})
}

type Job_SearchJobsServer interface {
	Send(*JobStatus) error
	grpc.ServerStream
}

type jobSearchJobsServer struct {
	grpc.ServerStream
}

func (x *jobSearchJobsServer) Send(m *JobStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Job_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Job_DeleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServer).DeleteJob(ctx, req.(*QueryJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Job_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Job_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServer).GetJob(ctx, req.(*QueryJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Job_ViewJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryJob)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServer).ViewJob(m, &jobViewJobServer{ServerStream: stream})
}

type Job_ViewJobServer interface {
	Send(*QueryResult) error
	grpc.ServerStream
}

type jobViewJobServer struct {
	grpc.ServerStream
}

func (x *jobViewJobServer) Send(m *QueryResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Job_ResumeJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExtendQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServer).ResumeJob(m, &jobResumeJobServer{ServerStream: stream})
}

type Job_ResumeJobServer interface {
	Send(*QueryResult) error
	grpc.ServerStream
}

type jobResumeJobServer struct {
	grpc.ServerStream
}

func (x *jobResumeJobServer) Send(m *QueryResult) error {
	return x.ServerStream.SendMsg(m)
}

// Job_ServiceDesc is the grpc.ServiceDesc for Job service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Job_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gripql.Job",
	HandlerType: (*JobServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Submit",
			Handler:    _Job_Submit_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _Job_DeleteJob_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _Job_GetJob_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListJobs",
			Handler:       _Job_ListJobs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchJobs",
			Handler:       _Job_SearchJobs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ViewJob",
			Handler:       _Job_ViewJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ResumeJob",
			Handler:       _Job_ResumeJob_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gripql.proto",
}

const (
	Edit_AddVertex_FullMethodName    = "/gripql.Edit/AddVertex"
	Edit_AddEdge_FullMethodName      = "/gripql.Edit/AddEdge"
	Edit_BulkAdd_FullMethodName      = "/gripql.Edit/BulkAdd"
	Edit_AddGraph_FullMethodName     = "/gripql.Edit/AddGraph"
	Edit_DeleteGraph_FullMethodName  = "/gripql.Edit/DeleteGraph"
	Edit_BulkDelete_FullMethodName   = "/gripql.Edit/BulkDelete"
	Edit_DeleteVertex_FullMethodName = "/gripql.Edit/DeleteVertex"
	Edit_DeleteEdge_FullMethodName   = "/gripql.Edit/DeleteEdge"
	Edit_AddIndex_FullMethodName     = "/gripql.Edit/AddIndex"
	Edit_DeleteIndex_FullMethodName  = "/gripql.Edit/DeleteIndex"
	Edit_AddSchema_FullMethodName    = "/gripql.Edit/AddSchema"
	Edit_SampleSchema_FullMethodName = "/gripql.Edit/SampleSchema"
	Edit_AddMapping_FullMethodName   = "/gripql.Edit/AddMapping"
)

// EditClient is the client API for Edit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EditClient interface {
	AddVertex(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error)
	AddEdge(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error)
	BulkAdd(ctx context.Context, opts ...grpc.CallOption) (Edit_BulkAddClient, error)
	AddGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error)
	BulkDelete(ctx context.Context, in *DeleteData, opts ...grpc.CallOption) (*EditResult, error)
	DeleteVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error)
	AddIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error)
	DeleteIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error)
	AddSchema(ctx context.Context, in *Graph, opts ...grpc.CallOption) (*EditResult, error)
	SampleSchema(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Graph, error)
	AddMapping(ctx context.Context, in *Graph, opts ...grpc.CallOption) (*EditResult, error)
}

type editClient struct {
	cc grpc.ClientConnInterface
}

func NewEditClient(cc grpc.ClientConnInterface) EditClient {
	return &editClient{cc}
}

func (c *editClient) AddVertex(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_AddVertex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddEdge(ctx context.Context, in *GraphElement, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_AddEdge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) BulkAdd(ctx context.Context, opts ...grpc.CallOption) (Edit_BulkAddClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Edit_ServiceDesc.Streams[0], Edit_BulkAdd_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &editBulkAddClient{ClientStream: stream}
	return x, nil
}

type Edit_BulkAddClient interface {
	Send(*GraphElement) error
	CloseAndRecv() (*BulkEditResult, error)
	grpc.ClientStream
}

type editBulkAddClient struct {
	grpc.ClientStream
}

func (x *editBulkAddClient) Send(m *GraphElement) error {
	return x.ClientStream.SendMsg(m)
}

func (x *editBulkAddClient) CloseAndRecv() (*BulkEditResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(BulkEditResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *editClient) AddGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_AddGraph_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteGraph(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_DeleteGraph_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) BulkDelete(ctx context.Context, in *DeleteData, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_BulkDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteVertex(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_DeleteVertex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteEdge(ctx context.Context, in *ElementID, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_DeleteEdge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_AddIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) DeleteIndex(ctx context.Context, in *IndexID, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_DeleteIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddSchema(ctx context.Context, in *Graph, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_AddSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) SampleSchema(ctx context.Context, in *GraphID, opts ...grpc.CallOption) (*Graph, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Graph)
	err := c.cc.Invoke(ctx, Edit_SampleSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *editClient) AddMapping(ctx context.Context, in *Graph, opts ...grpc.CallOption) (*EditResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditResult)
	err := c.cc.Invoke(ctx, Edit_AddMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EditServer is the server API for Edit service.
// All implementations must embed UnimplementedEditServer
// for forward compatibility
type EditServer interface {
	AddVertex(context.Context, *GraphElement) (*EditResult, error)
	AddEdge(context.Context, *GraphElement) (*EditResult, error)
	BulkAdd(Edit_BulkAddServer) error
	AddGraph(context.Context, *GraphID) (*EditResult, error)
	DeleteGraph(context.Context, *GraphID) (*EditResult, error)
	BulkDelete(context.Context, *DeleteData) (*EditResult, error)
	DeleteVertex(context.Context, *ElementID) (*EditResult, error)
	DeleteEdge(context.Context, *ElementID) (*EditResult, error)
	AddIndex(context.Context, *IndexID) (*EditResult, error)
	DeleteIndex(context.Context, *IndexID) (*EditResult, error)
	AddSchema(context.Context, *Graph) (*EditResult, error)
	SampleSchema(context.Context, *GraphID) (*Graph, error)
	AddMapping(context.Context, *Graph) (*EditResult, error)
	mustEmbedUnimplementedEditServer()
}

// UnimplementedEditServer must be embedded to have forward compatible implementations.
type UnimplementedEditServer struct {
}

func (UnimplementedEditServer) AddVertex(context.Context, *GraphElement) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddVertex not implemented")
}
func (UnimplementedEditServer) AddEdge(context.Context, *GraphElement) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddEdge not implemented")
}
func (UnimplementedEditServer) BulkAdd(Edit_BulkAddServer) error {
	return status.Errorf(codes.Unimplemented, "method BulkAdd not implemented")
}
func (UnimplementedEditServer) AddGraph(context.Context, *GraphID) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGraph not implemented")
}
func (UnimplementedEditServer) DeleteGraph(context.Context, *GraphID) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGraph not implemented")
}
func (UnimplementedEditServer) BulkDelete(context.Context, *DeleteData) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkDelete not implemented")
}
func (UnimplementedEditServer) DeleteVertex(context.Context, *ElementID) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVertex not implemented")
}
func (UnimplementedEditServer) DeleteEdge(context.Context, *ElementID) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEdge not implemented")
}
func (UnimplementedEditServer) AddIndex(context.Context, *IndexID) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddIndex not implemented")
}
func (UnimplementedEditServer) DeleteIndex(context.Context, *IndexID) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIndex not implemented")
}
func (UnimplementedEditServer) AddSchema(context.Context, *Graph) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSchema not implemented")
}
func (UnimplementedEditServer) SampleSchema(context.Context, *GraphID) (*Graph, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SampleSchema not implemented")
}
func (UnimplementedEditServer) AddMapping(context.Context, *Graph) (*EditResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMapping not implemented")
}
func (UnimplementedEditServer) mustEmbedUnimplementedEditServer() {}

// UnsafeEditServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EditServer will
// result in compilation errors.
type UnsafeEditServer interface {
	mustEmbedUnimplementedEditServer()
}

func RegisterEditServer(s grpc.ServiceRegistrar, srv EditServer) {
	s.RegisterService(&Edit_ServiceDesc, srv)
}

func _Edit_AddVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_AddVertex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddVertex(ctx, req.(*GraphElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_AddEdge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddEdge(ctx, req.(*GraphElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_BulkAdd_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EditServer).BulkAdd(&editBulkAddServer{ServerStream: stream})
}

type Edit_BulkAddServer interface {
	SendAndClose(*BulkEditResult) error
	Recv() (*GraphElement, error)
	grpc.ServerStream
}

type editBulkAddServer struct {
	grpc.ServerStream
}

func (x *editBulkAddServer) SendAndClose(m *BulkEditResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *editBulkAddServer) Recv() (*GraphElement, error) {
	m := new(GraphElement)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Edit_AddGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_AddGraph_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddGraph(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_DeleteGraph_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteGraph(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_BulkDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).BulkDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_BulkDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).BulkDelete(ctx, req.(*DeleteData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_DeleteVertex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteVertex(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_DeleteEdge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteEdge(ctx, req.(*ElementID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_AddIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddIndex(ctx, req.(*IndexID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_DeleteIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).DeleteIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_DeleteIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).DeleteIndex(ctx, req.(*IndexID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Graph)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_AddSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddSchema(ctx, req.(*Graph))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_SampleSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GraphID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).SampleSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_SampleSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).SampleSchema(ctx, req.(*GraphID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Edit_AddMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Graph)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EditServer).AddMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Edit_AddMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EditServer).AddMapping(ctx, req.(*Graph))
	}
	return interceptor(ctx, in, info, handler)
}

// Edit_ServiceDesc is the grpc.ServiceDesc for Edit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Edit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gripql.Edit",
	HandlerType: (*EditServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddVertex",
			Handler:    _Edit_AddVertex_Handler,
		},
		{
			MethodName: "AddEdge",
			Handler:    _Edit_AddEdge_Handler,
		},
		{
			MethodName: "AddGraph",
			Handler:    _Edit_AddGraph_Handler,
		},
		{
			MethodName: "DeleteGraph",
			Handler:    _Edit_DeleteGraph_Handler,
		},
		{
			MethodName: "BulkDelete",
			Handler:    _Edit_BulkDelete_Handler,
		},
		{
			MethodName: "DeleteVertex",
			Handler:    _Edit_DeleteVertex_Handler,
		},
		{
			MethodName: "DeleteEdge",
			Handler:    _Edit_DeleteEdge_Handler,
		},
		{
			MethodName: "AddIndex",
			Handler:    _Edit_AddIndex_Handler,
		},
		{
			MethodName: "DeleteIndex",
			Handler:    _Edit_DeleteIndex_Handler,
		},
		{
			MethodName: "AddSchema",
			Handler:    _Edit_AddSchema_Handler,
		},
		{
			MethodName: "SampleSchema",
			Handler:    _Edit_SampleSchema_Handler,
		},
		{
			MethodName: "AddMapping",
			Handler:    _Edit_AddMapping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BulkAdd",
			Handler:       _Edit_BulkAdd_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gripql.proto",
}

const (
	Configure_StartPlugin_FullMethodName = "/gripql.Configure/StartPlugin"
	Configure_ListPlugins_FullMethodName = "/gripql.Configure/ListPlugins"
	Configure_ListDrivers_FullMethodName = "/gripql.Configure/ListDrivers"
)

// ConfigureClient is the client API for Configure service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigureClient interface {
	StartPlugin(ctx context.Context, in *PluginConfig, opts ...grpc.CallOption) (*PluginStatus, error)
	ListPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListPluginsResponse, error)
	ListDrivers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListDriversResponse, error)
}

type configureClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigureClient(cc grpc.ClientConnInterface) ConfigureClient {
	return &configureClient{cc}
}

func (c *configureClient) StartPlugin(ctx context.Context, in *PluginConfig, opts ...grpc.CallOption) (*PluginStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginStatus)
	err := c.cc.Invoke(ctx, Configure_StartPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configureClient) ListPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, Configure_ListPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configureClient) ListDrivers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriversResponse)
	err := c.cc.Invoke(ctx, Configure_ListDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigureServer is the server API for Configure service.
// All implementations must embed UnimplementedConfigureServer
// for forward compatibility
type ConfigureServer interface {
	StartPlugin(context.Context, *PluginConfig) (*PluginStatus, error)
	ListPlugins(context.Context, *Empty) (*ListPluginsResponse, error)
	ListDrivers(context.Context, *Empty) (*ListDriversResponse, error)
	mustEmbedUnimplementedConfigureServer()
}

// UnimplementedConfigureServer must be embedded to have forward compatible implementations.
type UnimplementedConfigureServer struct {
}

func (UnimplementedConfigureServer) StartPlugin(context.Context, *PluginConfig) (*PluginStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartPlugin not implemented")
}
func (UnimplementedConfigureServer) ListPlugins(context.Context, *Empty) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlugins not implemented")
}
func (UnimplementedConfigureServer) ListDrivers(context.Context, *Empty) (*ListDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDrivers not implemented")
}
func (UnimplementedConfigureServer) mustEmbedUnimplementedConfigureServer() {}

// UnsafeConfigureServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigureServer will
// result in compilation errors.
type UnsafeConfigureServer interface {
	mustEmbedUnimplementedConfigureServer()
}

func RegisterConfigureServer(s grpc.ServiceRegistrar, srv ConfigureServer) {
	s.RegisterService(&Configure_ServiceDesc, srv)
}

func _Configure_StartPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigureServer).StartPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Configure_StartPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigureServer).StartPlugin(ctx, req.(*PluginConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Configure_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigureServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Configure_ListPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigureServer).ListPlugins(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Configure_ListDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigureServer).ListDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Configure_ListDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigureServer).ListDrivers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Configure_ServiceDesc is the grpc.ServiceDesc for Configure service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Configure_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gripql.Configure",
	HandlerType: (*ConfigureServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartPlugin",
			Handler:    _Configure_StartPlugin_Handler,
		},
		{
			MethodName: "ListPlugins",
			Handler:    _Configure_ListPlugins_Handler,
		},
		{
			MethodName: "ListDrivers",
			Handler:    _Configure_ListDrivers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gripql.proto",
}
